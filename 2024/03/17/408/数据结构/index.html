<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>数据结构 | 11的Blog</title><meta name="keywords" content="408,数据结构"><meta name="author" content="11andyy"><meta name="copyright" content="11andyy"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="数据结构"><meta name="application-name" content="数据结构"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="数据结构"><meta property="og:url" content="https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html"><meta property="og:site_name" content="11的Blog"><meta property="og:description" content="数据结构绪论graph LR    绪论--&amp;gt;数据结构    绪论--&amp;gt;五个特征        数据结构--&amp;gt;逻辑结构    数据结构--&amp;gt;物理结构    数据结构--&amp;gt;数据运算        五个特征--&amp;gt;算法定义    五个特征--&amp;gt;五个特性    五个"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729161024495.png"><meta property="article:author" content="11andyy"><meta property="article:tag" content="11的Blog"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729161024495.png"><meta name="description" content="数据结构绪论graph LR    绪论--&amp;gt;数据结构    绪论--&amp;gt;五个特征        数据结构--&amp;gt;逻辑结构    数据结构--&amp;gt;物理结构    数据结构--&amp;gt;数据运算        五个特征--&amp;gt;算法定义    五个特征--&amp;gt;五个特性    五个"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><link rel="preconnect" href="//cdn.cbd.int"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/swiper/swiper.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: {"enable":true,"title":"与数百名博主无限进步","addFriendPlaceholder":"昵称（请勿包含博客等字样）：\n网站地址（要求博客地址，请勿提交个人主页）：\n头像图片url（请提供尽可能清晰的图片，我会上传到我自己的图床）：\n描述：\n站点截图（可选）：\n"},
  peoplecanvas: undefined,
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"tianli","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"不要走！再看看嘛！","backTitle":"欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 小猪","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":null},
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["🤖️ 数码科技爱好者","🔍 分享与热心帮助","🏠 智能家居小能手","🔨 设计开发一条龙","🤝 专修交互与设计","🏃 脚踏实地行动派","🧱 团队小组发动机","💢 壮汉人狠话不多"]},
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 11andyy","link":"链接: ","source":"来源: 11的Blog","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: {"enable":true,"delay":100,"shiftDelay":200},
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '11的Blog',
  title: '数据结构',
  postAI: '',
  pageFillDescription: '数据结构, 绪论, 数据结构的基本概念, 数据结构的三要素, 算法和算法评价, 算法效率的度量, 时间复杂度, 空间复杂度, QampA, 线性表, 线性表的基本定义和基本操作, 线性表的定义, 线性表的基本操作, 顺序表和链表的比较, QampA, 栈、队列、数组, 栈, 栈的基本概念, 顺序栈、链栈、共享栈, 队列, 队列的基本概念, 顺序队列、链式对联、双端队列、循环队列, 栈和队列的应用, 栈在括号匹配中的算法思想, 栈在后缀表达式求值中的算法思想, 栈在递归中的应用, 队列在层次遍历中的应用, 队列在计算机系统中的应用, 数组和特殊矩阵, 数组的存储方式, 特殊矩阵, QampA, 串, 串的模式匹配, 树与二叉树, 树和二叉树的基本概念, 树和二叉树的性质, 树的存储结构, 二叉树的存储结构, 二叉树的遍历, 树和森林的遍历, 线索二叉树（没学）, 树、二叉树、森林的转换, 树和二叉树的应用, 哈夫曼树和哈夫曼编码, 并查集, 图, 图的基本概念, 图的存储, 图的遍历, 最小生成树, Kruskal（稀疏图）, Prim（稠密图）, 最短路径, Dijkstra, Bellman-Ford, Spfa, Floyd, 查找, 查找的基本概念, 查找类型, 线形查找, 顺序查找, 折半查找（二分查找）, 分块查找, 树形查找, 二叉排序树（BST）, 平衡二叉树（AVL）, 红黑树（RBT）, B树和B+树, B树, B+树, 散列表, 排序, 排序的基本概念, 插入排序, 插入排序, 希尔排序, 交换排序, 冒泡排序, 快速排序, 选择排序, 选择排序, 堆排序, 归并排序和基数排序, 归并排序, 基数排序, 外部排序数据结构绪论绪论数据结构绪论五个特征数据结构逻辑结构数据结构物理结构数据结构数据运算五个特征算法定义五个特征五个特性五个特征效率的度量逻辑结构逻辑结构有穷性确定性可行性输入输出五个特性效率的度量时间复杂度效率的度量空间复杂度线性结构线性表栈队列非线性结构树图集合数据结构的基本概念数据结构的三要素逻辑结构线性结构线性表对非线性结构集合同属于一个集合树对多图多对多存储结构物理结构顺序存储逻辑上相邻的元素存储在物理位置上也相邻的存储单元中优随机存取每个元素占空间少缺只能使用相邻的整块存储单元产生较多外部碎片链式存储不要求逻辑上相邻的元素在物理位置上也相邻借助指针来表示元素之间的逻辑关系优不会出现外部碎片缺指针占用额外的存储空间只能实现顺序存取索引存储存储信息元素同时建立附加的索引表索引表中的每项为索引项关键字地址优检索快缺索引表占用额外空间增删数据需要修改索引表散列存储哈希存储根据元素的关键字直接计算存储地址优检索增加删除节点速度快缺散列函数不好会产生冲突数据的运算算法和算法评价算法效率的度量时间复杂度一个语句的频度是指该语句在算法中被重复执行的次数所有语句的频度之和为他是该算法问题规模的函数时间复杂度主要分析的数量级算法中最深层循环内的语句的频度与同数量级因此通常采用最深层循环内的语句的频度来分析算法的时间复杂度因此时间复杂度为上式中的含义是的数量级表示同阶同等数量级数量级比较主定理求时间复杂度形如与比较空间复杂度算法的空间复杂度定义为该算法所需要的存储空间它是问题规模为的函数记为只需要关注存储空间的大小和与问题规模相关的变量用循环比递归的效率高吗循环和递归两者是可以互换的不能决定性的说循环的效率比递归高递归的优点是代码清晰容易检查正确性缺点是当递归调用的次数较多时要增加额外的堆栈处理有可能产生堆栈溢出的情况循环的优点是结构简单速度快缺点是它不能解决全部的问题有的问题适合用递归来解决不适合用循环贪心法动态规划法以及分治法的区别贪心算法顾名思义就是做出当前来看是最好的结果它不从整体上加以考虑也就是局部最优解贪心从上往下从顶部一步一步最优得到最后的结果它不能保证全局最优解与贪心选择的策略有关动态规划法把问题分解成子问题这些子问题可能有重复可以记录下前面的子问题的结果防止重复计算前一个子问题对后一个子问题产生一定的影响分治法将原问题划分为个小规模的子问题递归的解决这些子问题然后再合并子问题的解就是原问题的解线性表线性表顺序存储线性表链式存储顺序存储顺序表链式存储单链表链式存储双链表链式存储循环链表静态链表借助数组实现链式存储线性表的基本定义和基本操作线性表的定义线性表是具有相同数据类型的个数据的有限序列除第一个元素和最后一个元素每个元素都有一个直接前驱和直接后继线性表的基本操作初始化表长按值查找返回位置按位置查找返回值插入元素删除元素打印表判空销毁表顺序表和链表的比较存取方式顺序表可以顺序存取也可以随机存取链表只能从表头顺序存取元素例如在第个位置上执行存取操作顺序表仅需一次访问而链表需要从头访问物理结构都是线性结构顺序表逻辑上相邻的元素存储的物理位置也相邻链表逻辑上相邻的元素存储物理位置不一定相邻查找插入删除操作对于按值查找顺序表无序时两者时间复杂度都是顺序表有序时二分查找时间复杂度为对于按序号查找顺序表时间复杂度为链表的时间复杂度为对于插入删除操作顺序表需要平均移动半个表长链表只需要修改指针即可空间分配顺序表在静态存储空间分配下一旦装满就不能扩充预先分配过大造成浪费过小造成溢出链表只需要在需要时申请分配只要内存有空间就可以分配头指针和头节点的区别头指针指向第一个节点存储位置的指针具有标识作用无论链表为空头指针必须存在头节点是放在第一个元素的节点之前便于在第一个元素之前进行插入和删除操作头节点不是链表的必须元素可有可无数据域也不存放任何信息栈队列数组线性表操作受限栈栈顺序栈栈链栈栈共享栈线性表操作受限队列队列顺序队列队列链式队列队列双端队列队列循环队列线性表推广数组栈栈的基本概念栈只允许在一端进行插入和删除的线性表顺序栈链栈共享栈顺序栈后进先出链栈共享栈利用栈底相对位置不变的特性可以让两个顺序栈共享一个一维数组空间将两个共享栈的栈底设置为两端栈顶指针向中间靠拢队列队列的基本概念队列只允许在一端插入在另一端删除顺序队列链式对联双端队列循环队列顺序队列先进先出队头指针队尾指针存在假溢出现象链式队列循环队列将队列臆造为一个环状空间利用除法取余解决溢出问题双端队列允许两端都可以插入和删除的线性表栈和队列的应用栈在括号匹配中的算法思想凡是出现左括号则进栈凡是出现右括号首先检查栈是否空若空则右括号多余否则和栈顶元素进行比较若相匹配则栈顶左括号出栈表达式检验结束若栈空则匹配正确否则说明左括号有多余栈在后缀表达式求值中的算法思想中缀转后缀按运算顺序加括号将运算符移动至对应右括号的前面除去所有的括号计算机中缀转后缀遇到操作数直接加入后缀表达式遇到左括号直接入栈遇到右括号依次弹出栈中的运算符加入后缀表达式直到弹出左括号左括号删除不加入后缀表达式遇到运算符优先级高于栈顶或入栈低于栈顶一直出栈直至高于然后把当前符号入栈顺序扫描表达式的每一项根据它的类型做出相应的操作若是操作数压栈若是操作符从栈顶退出两个操作数形成运算指令将结果重新压栈表达式求完栈顶的数就是结果栈在递归中的应用递归算法转换为非递归算法通常需要借助栈来实现队列在层次遍历中的应用二叉树的层次遍历每次队头出队扩展队头直到队空队列在计算机系统中的应用解决主机与外部设备之间速度不匹配的问题以主机和打印机为例主机输出数据给打印机打印输出数据的速度比打印机快得多若直接把输出数据送给打印机显然不行解决的方法是设置一个打印缓冲区主机把打印数据写入这个缓冲区写满后就暂停输出打印机从缓冲区按照先进先出的原则进行打印打印完后向主机发出请求主机再把数据写入缓冲区保证的打印的数据准确由提高了主机的效率由此可见打印数据缓冲区中所存储的数据就是一个队列解决由多用户引起的资源竞争问题以的资源竞争为例在一个多终端的计算机上多个用户需要运行程序通过各自的终端提出占用的请求操作系统按照请求的时间先后顺序把他们排成一个对立每次把分给队首用户使用当用户程序执行完毕或者是分配的时间片用完令其出队再把给新的队首使用数组和特殊矩阵数组的存储方式按行优先存储和按列优先存储特殊矩阵对称矩阵三角矩阵稀疏矩阵如何区分循环队列是空还满普通情况下循环队列队空和队满的条件一样队头指针指向第一个数队尾指针指向最后一个数的下一个位置即即将入队的位置法牺牲一个存储单元来区分队空和队满法增设标识元素个数的数据成员队空队满串基本概念主串子串串长串串存储结构定长顺序存储堆分配存储块链存储存储结构串模式匹配算法模式匹配算法暴力匹配模式匹配算法数组模式匹配算法数组算法的改进串的模式匹配求模式串在子串中的位置树与二叉树树二叉树树树和森林概念定义存储结构概念定义存储结构二叉树二叉树操作操作三种遍历操作线索二叉树二叉树应用应用排序二叉树排序二叉树平衡二叉树应用哈夫曼树树和森林操作应用树和森林树和森林遍历与二叉树的转换并查集树和二叉树的基本概念树树是非线性结构节点之间有明显的层次关系根节点没有前驱除根结点每个节点有且只有一个前驱叶节点没有后继除叶节点每个节点有多个后继递归定义或者为空树或者由一个根节点和个不相交的被称为根的有限集子树组成每个集合又是一棵树祖先根到某个节点路径上的所有节点子孙某个节点下面的所有节点双亲父节点孩子子节点兄弟相同父节点的子节点堂兄弟双亲在同一层的子节点节点的度孩子节点的个数树的度节点的最大度数分支节点度大于的节点叶子节点度为的节点节点层次节点所在的层的深度根为树高度节点的最大层数节点的高度以该节点为根的子树的高度有序树各个子树不能交换路径两个节点路径序列路径长度两个节点路径的边数二叉树二叉树每个节点最多有两颗子树并且二叉树的子树有左右之分次序不能任意颠倒递归定义或者为空二叉树或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成左子树和右子树又分别为二叉树满二叉树除了叶子节点每个节点均有两棵子树特点高度为有个节点根节点编号为左孩子为右孩子为双亲为完全二叉树除了最后一层外其他任何一层的节点数均达到最大值且最后一层也只是在最右侧缺少节点二叉排序树左子树关键字小于根节点右子树关键字大于根节点左子树和右子树又分别是二叉排序树平衡二叉树树中任意一个节点的左子树和右子树高低之差的绝对值不超过正则二叉树每个分支节点的出度为当是满二叉树森林不相交的树的集合树和二叉树的性质树的节点数等于所有节点的度数之和节点的度数等于节点的孩子数最后在加上根节点非空二叉树上的叶子节点数度为的节点数证明分支数得到非空二叉树的第层最多有个节点高度为的二叉树最多有个节点对于完全二叉树从上到下从左到右编号若则节点为分支节点即最后一个分支节点的编号是度为的节点只可能是最后一个分支节点的双亲节点为节点所在的层次深度为具有个节点的完全二叉树的高度为或证明根据完全二叉树的定义为整数或者树的存储结构双亲表示法采用顺序存储结构每个节点增设伪指针值为双亲的存储下标孩子表示法每个节点的孩子表示为一个线性表以单链表为存储结构头指针组成线性表以顺序表为存储结构孩子兄弟表示法二叉树表示法以二叉链表作为树的存储结构每个节点包括节点值指向节点第一个孩子的指针指向孩子下一个兄弟的指针孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法简记为左儿子右兄弟二叉树的存储结构顺序存储结构数组下标为二叉树节点的编号建议数组下标从开始链式存储结构数据域指针域二叉树的遍历遍历二叉树的先序中序后序实际上就是看先根中根后根先根中根后根层次遍历根节点入队取出队头扩展队头入队由遍历序列构造二叉树中序遍历可以得到唯一的二叉树中序先序中序先序先序是走根中序把根分为了左右左侧为左子树右侧为右子树然后递归分析下去中序后序中序后序后序最后一个节点是根中序层次层序遍历中第一个节点一定是根节点将中序序列分割成了左子树的中序序列和右子树的中序序列若存在左子树则层序序列的第二个节点一定是左子树的根可以进一步划分左子树树和森林的遍历树的遍历先根遍历后根遍历层次遍历森林的遍历先序遍历森林访问第一棵树的根节点先序遍历第一棵树中根节点的子树森林再访问森林中的其他树组成的森林先序遍历森林对森林组成的二叉树的先序遍历对各个树先序遍历中序遍历森林中序遍历第一棵树中根节点的子树森林访问第一棵树的根节点中序遍历其他的树组成的森林中序遍历森林对森林组成的二叉树的中序遍历对各个树后序遍历最靠谱的方法把森林转为二叉树左孩子右兄弟先序遍历中序遍历线索二叉树没学定义以一定的规则将二叉树的节点排成一个线性序列从而得到几种遍历序列使得该序列中的每个节点都有一个直接前驱和直接后继首位节点除外理解就是把树变成线性表树二叉树森林的转换树转为二叉树左儿子右兄弟森林转换为二叉树先将每棵树转为二叉树因为每棵转换后二叉树的右儿子必空因此用另一棵二叉树作为右儿子二叉树转为森林每次都将二叉树的根和左子树组在一起和右子树分开直到右子树不能再分再把每棵二叉树转为树就得到了原始的森林树和二叉树的应用哈夫曼树和哈夫曼编码带权路径长度之和哈夫曼树的构造哈夫曼编码左右并查集详见算法图图图的定义图图的存储图图的遍历图图的应用图的存储邻接矩阵图的存储邻接表图的遍历图的遍历最小生成树最短路径拓扑排序网关键路径网图的应用图的应用图的应用图的应用图的基本概念图的定义顶点集和边集组成各种图有向图无向图简单图不存在重边和自环完全图简单完全图有条边的无向图或者条边的有向图称为完全图子图两个图是的子集是的子集若有满足的子图则称为的生成子图点全部包括连通连通图和连通分量连通从到有路径则到连通连通图任意两个点都有路径连通分量无向图的极大连通子图称为连通分量强连通图强连通分量到有路径到有路径则是强连通有向图的极大强连通子图称为强连通分量生成树生成森林生成树连通图的生成树是包含图中全部顶点的一个极小连通子图个顶点条边生成森林在非连通图中连通分量的生成树构成了分连通图的生成森林顶点的度入度出度有向图的度入度出度边的权和网边上带权重的图为网稠密图稀疏图课视为稀疏图路径路径长度回路到路径边数为路径长度个顶点大于条边此图一定有环简单路径简单回路路径序列中顶点不重复出现称为简单路径回路中除了第一个点其余点不重复出现为简单回路距离有向树一个顶点的入度为其余顶点入度为的有向图称为有向树图的存储邻接矩阵法稠密图邻接表法稀疏图存储空间无向图有向图十字链表有向图的链式存储结构每个弧有一个节点每个顶点也是一个节点邻接多重表无向图的链式存储结构图的遍历深度优先搜索广度优先搜索最小生成树一个连通图的生成树包含图的所有顶点并且含有尽可能少的边对于带权的连通无向图权值之和最小的树为最小生成树稀疏图存点的父节点初始化并查集把个点放在个独立的集合将所有边按边权从小到大排序贪心思想按顺序枚举每条边如果这条边连接的两个点不在同一个集合就把这条边加入最小生成树并且合并这两个集合如果这条边连接的两个点在同一个集合就跳过因为不能成环重复执行直到选取了条边为止稠密图算法流程类似于不断选取不在圈内且距离圈最小的点直到所有点都加入了圈初始化所有点都不在圈内其他点每次选取不在当前集合中且离圈最近的点打标记加入集合对的所有邻点的距离执行更新操作重复步操作直到没有点能加入集合中最短路径时间复杂度算法是基于贪心思想的单源最短路算法集合已经确定好最短路的节点组成的集合初始时所有的点都不在集合中其他点迭代次每次选出不在当前集合中且离源点最近的点将该点放入集合用该点进行松弛操作更新与它相邻的点的距离算法是基于松弛操作的单源最短路算法存点的出边的邻点和边权存点到源点的距离初始化其他点执行多轮循环每轮循环对所有边都尝试进行一次松弛操作当一轮循环中没有成功的松弛操作时算法停止时间复杂度算法的优化只有本轮被更新的点其出边终点才有可能引起下一轮的松弛操作因此用队列来维护被更新的出边终点的集合标记点是否在队内记录边数判负环初始化入队标记在队内其他点从队头弹出点标记不在队内枚举的所有出边进行松弛操作记录到走过的边数并判负环如果不在队内则把压入队尾并打上标记重复步骤直到队内为空时间复杂度弗洛伊德算法是动态规划算法也称为插点法是全源最短路算法状态表示表示从到且中间只经过节点编号为的最短路径的长度状态计算路径的选择分为两类路径不经过点继承原值路径经过点松弛操作说明计算第层的时必须先将层的所有状态计算出来所以需要把放在最外层状态可以理解为第层的二维表向第层的二维表的投射两类状态都是调用的上一层因此用滚动数组就可以优化掉初始化无边有边查找基本概念静态查找动态查找散列结构散列表效率指标平均查找长度查找查找线性结构线性结构顺序查找线性结构折半查找线性结构分块查找查找树形结构树形结构二叉排序树树形结构二叉平衡树树形结构树树形结构树查找性能分析查找查找成功查找失败查找的基本概念静态查找和动态查找一个查找表的操作只涉及查找操作则无需动态地修改查找表反之需要动态地插入和删除的查找称为动态查找适合静态查找有顺序查找折半查找散列查找适合动态查找有二叉排序树的查找散列查找平均查找长度一次查找的长度是指需要比较关键字的次数平均查找长度是查找过程进行关键字次数比较的平均值是查找表的长度是查找第个数据元素的概率一般认为是是找到第个数据元素需要进行比较的次数查找类型线形查找顺序查找从线性表的一端开始逐个检查关键字是否符合条件若查找的关键字符合条件则查找成功若查找到表的另一端则查找失败时间效率为折半查找二分查找适用于所有有序的顺序表时间复杂度最大化查找可行区在左侧开区间时结束最小化查找可行区在右侧开区间时结束指针跳跃的次数为指针指向区间的两侧外面时循环结束可行区的指针最后一定指向答案开区间可以正确处理边界分块查找先把查找表分为若干子表要求每个子表的元素都要比它后面子表的元素小也就是保证块间是有序的但是子表内部不一定有序把各个子表的最大关键字构成一张索引表表中还含各个子表的起始地址特点是快间有序块内无序查找时块间进行索引查找块内进行顺序查找树形查找二叉排序树查找插入删除或者是一棵空树或者是一棵有特点的树如果该树有左子树左子树所有节点小于根节点如果有右子树右子树所有节点大于根节点左右子树都是二叉排序树在查找时可以进行动态插入和删除因此对二叉排序树进行中序遍历可以得到一个有序序列查找伪代码比较根节点大于根节点查找右儿子小于根节点查找左儿子插入若原二叉排序树为空直接插入关键字小于根节点则插入到左子树关键字大于根节点插入到右子树插入的节点一定是一个新添加的叶子节点删除二叉排序树删除一个节点时不能把以该节点为根的子树上的节点都删除必须先把被删除节点从二叉排序树的链表上摘下将因删除节点而断开的二叉链表重新连接起来确保二叉排序树的性质不会丢失若删除节点是叶子节点直接删除若节点只有一棵左子树或者只有一棵右子树则让的子树称为父节点的子树代替的位置若节点有左右两棵子树则令的直接后继或直接前驱代替然后从二叉排序树中删去这个直接后继或直接前驱这样就转换成了第一种或第二种情况两个思路修改左子树找到将被删除节点的左子树中的最大值走到左子树一路往右下走将这个最大值保存并删除这个节点将我们保存到的左子树最大值替换给将被删除的节点的值修改右子树找到将被删除节点的右子树中的最小值走到左子树一路往左下走将这个最小值保存并删除这个节点将我们保存的右子树的最小值替换给将被删除节点的值平衡二叉树查找插入删除平衡二叉树的定义为了避免树的高度增长过快降低二叉排序树的性能规定在插入和删除节点时要保证任意节点的左右子树高度差的绝对值不超过这样的二叉树称为平衡二叉树也称树定义左子树的高度和右子树高度差为该节点的平衡因子取值为插入右孩子左旋左孩子右旋每当在二叉排序树插入或删除节点时其路径上的节点是否因为此次操作会导致不平衡若导致了不平衡则先找到插入路径上离插入节点最近的平衡因子的绝对值大于的节点再对以为根的子树调整位置使之平衡每次调整的对象都是最小不平衡子树即以查找路径上离插入节点最近的不平衡因子节点为根的子树从插入节点往上找前半部分和二叉排序树一样新节点插入以后关注查找路径上的不平衡因子有四种情况在的左孩子的左子树中插入导致不平衡向右上旋转成为根节点向右下旋转成为的右子树其余节点按照顺序进行排列在的右孩子的右子树中插入导致不平衡向左上旋转成为根节点向左下旋转成为的左子树其余节点按照顺序进行排列在的左孩子的右子树中插入导致不平衡把节点拆开看情况问题分为两步第一步让向左上旋转代替让向左下旋转成为的左子树第二步让向右上旋转代替让向右下旋转成为的右子树在的右孩子的左子树中插入导致不平衡把节点拆开看情况问题分为两步第一步让向右上旋转代替让向右下旋转成为的右子树第二步让向左上旋转代替让向左下旋转成为的左子树右旋左旋删除删除节点方法同二叉排序树左子树的最大值或右子树的最小值代替删除的节点一路向北找到最小不平衡树找不到就结束了找最小不平衡树下个头最高的儿子孙子根据孙子的位置调整平衡孙子在位置儿子右旋孙子在位置儿子左旋孙子在位置孙子先左旋后右旋孙在在位置孙子先右旋后左旋如果不平衡向上传导继续检查不平衡是否向上传导了右侧的子树高度变矮导致上方的节点又不平衡了查找红黑树左根右根叶黑不红红黑路同查找插入删除树插入或删除会影响平衡特性因此需要频繁调整平衡树这就造成了时间开销变大红黑树插入和删除很多时候不会破坏红黑特性无需频繁调整树的形态即便是要调整也能在常数级的时间内完成红黑树的定义红黑树是二叉排序树左根右每个节点是红色的或是黑色的根节点是黑色的叶子节点失败节点是黑色的不存在两个相邻的红节点即红节点的父节点和孩子节点均是黑色对于每个节点从该节点到任一叶节点的简单路径上所含黑节点的数目相同黑高从某个节点出发不含该节点到任一空叶节点的路径上黑节点的总数红黑树的性质从根节点到叶节点的最长路径不大于最短路径的倍路径最长的情况是红节点穿插在每个黑节点之间还有可能一条路径上全是黑节点没有红节点有个内部节点的红黑树高度时间复杂度插入查找确定插入的位置同二叉排序树插入新新节点新节点是根黑色新节点非根红色判断破坏不红红这个规则没插入后满足则结束不满足调整使其重新满足红黑树定义黑色的叔叔旋转染色右单旋父换爷染色左单旋父换爷染色染色是染父和爷左右双旋儿换爷染色染色是染儿和爷右左双旋儿换爷染色红色的叔叔染色变新叔父爷染色爷节点变为新节点用同样的逻辑判断新节点删除比较难查找从根出发左小右大如果查到空叶节点则查找失败树和树五叉排序树每个节点四个关键字最多五个孩子如何保证查找效率策略叉查找树规定除了根节点之外任何节点至少有个分叉至少含有个关键字叉查找树规定任何一个节点所有子树的高度相同满足这些要求就是树树定义树多路平衡查找树树种所被允许的孩子个数的最大值称为树的阶分叉数的最大值特性根节点关键字数分支数分支节点关键字数分支数分支数关键字数所有叶子节点出现在同一个层次上并且不带信息可以视为查找失败的节点非叶子节点的数据结构查找在树中查找节点在节点内查找关键字插入定位利用查找算法找出插入关键字的终端节点不是叶节点虽然会查找失败插入每个非根节点的关键字的个数在到若插入后在这个范围内则可以插入若大于个必须对节点进行分裂插入的一定是倒数第二层的终端节点分裂的方法从第个关键字分裂让他成为父节点删除若被删除的关键字在终端节点则直接删除关键字要注意关键字的下限是否是若被删除的关键字有左右子树找它的直接前驱或者是直接后继来顶替它走进左子树一直往右下找或走进右子树一直往坐下找若删除后低于下限了兄弟够借右兄弟很宽裕用当前节点的后继后继的后继来填补空缺左兄弟很宽裕用当前节点的前驱前驱的前驱来填补空缺兄弟不够借合并兄弟以及父节点被夹的关键字树树是应数据库所需而出现的一种树的变形树和分块查找差不多索引表存的是最大的关键字根节点关键字数分支数分支节点关键字数分支数分支数关键字数所有的叶子节点包含全部的关键字叶子节点按照关键字从小到大排列并且相邻叶子节点按大小顺序互相链接查找阶树和树的区别树个关键字对应棵子树树个关键字对应棵子树树根节点关键字数其他节点树根节点关键字数其他节点树节点的关键字不会重复包含了对应记录的存储地址树叶子节点包含全部关键字非叶节点出现的关键字在叶子节点也会出现非叶子节点只起索引作用不包含对应记录的存储地址树非叶子节点不含存储地址同样大小的磁盘块可以使得一个磁盘块包含更多的关键字树的阶更大树高更矮读磁盘数更少查找更快散列表散列表的基本概念散列表是一种数据结构可以根据数据元素的关键字计算出它在散列表中的存储地址散列函数建立了关键字到存储地址的映射关系冲突插入关键字计算得到的处已经存储了其他元素则产生了碰撞散列函数的构造设计散列函数的目标定义域涵盖所有关键字值域不能超过散列表的地址范围尽可能减少冲突均匀分布在整个地址空间内散列函数尽量简单能够快速计算出散列地址除留余数法最常用散列表长度为取一个不大于但是接近或等于的质数直接定址法关键字分布基本连续例如连续的学生学号可以进行线性映射数字分析法关键字集合已知且关键字某几个数码位分布均匀选取数码分布较均匀的若干位作为散列地址例如手机号的后四位平方取中法关键字的每位取值都不够均匀对关键字求平方然后取中间两个数值位作为散列地址处理冲突的方法拉链法如何插入把所有冲突的存储在一个链表中默认头插法如何查找分析查找长度如何删除先查找后删除开放寻址法第一次冲突原理如果插入元素时发生冲突就另外找一个空闲的位置加上一个偏移序列线性探测法对应第次冲突其实就是一个个往后找直到找到为空的地方将元素放进去平方探测法双散列法伪随机序列法让是一个伪随机序列然后根据这个处理冲突排序排序基本概念基本概念稳定性基本概念衡量标准时空复杂度排序内部排序内部排序插入排序插入排序直接插入排序插入排序折半插入排序插入排序希尔排序交换排序冒泡排序交换排序快速排序内部排序交换排序内部排序选择排序选择排序简单选择排序选择排序堆排序内部排序归并排序内部排序基数排序排序外部排序外部排序多路归并排序排序的基本概念关键字有序关键字可能重复和前面不一样排序算法的稳定性经过排序算法处理后相同的关键字原本的相对位置没有改变内部排序和外部排序内部排序全在内存中外部排序因为数据太多无法放入内存也要关注磁盘的读写次数插入排序插入排序算法思想每次将一个待排序的记录按其关键字大小插入到前面已经排序好的子序列中直到全部插入时间复杂度稳定的优化折半插入排序因为前面已经有序了因此可以用二分找到应该插入的位置希尔排序算法思想使得原本的序列保持基本上有序这样插入排序的效率可以提高一点然后逐步逼近全局有序将排序表分割成若干子表对各个子表进行直接插入排序缩小增量重复上述过程直到为止总体基本有序了然后再进行一次直接插入排序时间复杂度不稳定的交换排序冒泡排序算法思想从后往前两两比较大的元素下沉小的元素上浮每趟排序都会使得最小的元素浮到最上方第趟排序交换到第个位置停下来就可以了从开始两个元素相同不必交换位置可以保证稳定性趟即可时间复杂度稳定的快速排序算法思想主要利用分治思想详见算法令指针指向数列的区间外侧数列的中值记为将数列中的数放左段的数放右段对于左右两段再递归以上两个过程直到每段只有一个数即全部有序时间复杂度不稳定的选择排序选择排序算法思想每一趟在待排序元素中选取关键字最小或最大的元素加入到有序子序列实现方式是和待排序元素的头部节点交换图中蓝色趟即可完成时间复杂度不稳定的堆排序算法思想堆的插入先将元素从堆尾插入然后上浮到合适的位置上浮压入堆的删除删除最小的元素先将堆顶的数和堆尾的数交换删除堆尾然后下沉操作下沉找出子节点中较小的那个数存在父节点比子节点大删除时间复杂度不稳定的归并排序和基数排序归并排序算法思想主要利用分治思想时间复杂度对数组不断的等长拆分直到一个数的长度回溯时按升序合并左右两段重复以上两个过程直至递归结束回溯合并指针分别指向的左右段起点指向的起点枚举数组如果左数右数把左数放入数组否则把右数放入数组把左段或右段剩余的数放入数组把数组当前段复制回数组用于数组的上一层回溯时间复杂度稳定的基数排序算法思想建立个队列以关键字的个位数排队放入队列中按顺序收集队列中的元素组成链表得到按照个位递减的排序序列以关键字的十位数排队放入队列中个位越大的越先入队使得大数在前小数在后收集得到按十位递减的排序序列十位相同的按照个位递减排序以关键字的百位数排队放入队列中十位越大的越先入队使得大数在前小数在后收集得到按百位递减的排序序列百位相同按照十位递减排序十位相同的按照个位递减排序最终有序时间复杂度稳定的外部排序',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-07-29 16:25:37',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://index.anheyu.com/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2748ef34.jpg" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/07/23/64bc72c75319d.png" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">11的Blog</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechatpay.jpg"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size: 1.05rem;">408<sup>4</sup></a><a href="/tags/Anaconda/" style="font-size: 1.05rem;">Anaconda<sup>1</sup></a><a href="/tags/Carla/" style="font-size: 1.05rem;">Carla<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 1.05rem;">Docker<sup>1</sup></a><a href="/tags/Git/" style="font-size: 1.05rem;">Git<sup>1</sup></a><a href="/tags/Latex/" style="font-size: 1.05rem;">Latex<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 1.05rem;">Linux<sup>1</sup></a><a href="/tags/Pipe/" style="font-size: 1.05rem;">Pipe<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>1</sup></a><a href="/tags/Ros/" style="font-size: 1.05rem;">Ros<sup>1</sup></a><a href="/tags/SCP/" style="font-size: 1.05rem;">SCP<sup>1</sup></a><a href="/tags/SSH/" style="font-size: 1.05rem;">SSH<sup>1</sup></a><a href="/tags/Tmux/" style="font-size: 1.05rem;">Tmux<sup>2</sup></a><a href="/tags/Vim/" style="font-size: 1.05rem;">Vim<sup>2</sup></a><a href="/tags/easyRL%E7%A3%A8%E8%8F%87%E4%B9%A6/" style="font-size: 1.05rem;">easyRL磨菇书<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 1.05rem;">图床<sup>1</sup></a><a href="/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" style="font-size: 1.05rem;">实用教程<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/" style="font-size: 1.05rem;">工具配置<sup>1</sup></a><a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">强化学习<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">文本编辑工具<sup>2</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">机器人操作系统<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/" style="font-size: 1.05rem;">深度学习工具<sup>5</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 1.05rem;">编程语言<sup>1</sup></a><a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" style="font-size: 1.05rem;">自动驾驶<sup>2</sup></a><a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E4%BB%BF%E7%9C%9F/" style="font-size: 1.05rem;">自动驾驶仿真<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 1.05rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">计算机网络<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span><a class="card-more-btn" href="/archives/" title="查看更多">
    <i class="anzhiyufont anzhiyu-icon-angle-right"></i></a></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/07/"><span class="card-archive-list-date">七月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">4</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/05/"><span class="card-archive-list-date">五月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/03/"><span class="card-archive-list-date">三月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/01/"><span class="card-archive-list-date">一月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/12/"><span class="card-archive-list-date">十二月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/09/"><span class="card-archive-list-date">九月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div><div class="console-btn-item" id="consoleKeyboard" onclick="anzhiyu.keyboardToggle()" title="快捷键开关"><a class="keyboard-switch"><i class="anzhiyufont anzhiyu-icon-keyboard"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/408/" itemprop="url">408</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/408/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>408</span></a><a class="article-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>数据结构</span></a></span></div></div><h1 class="post-title" itemprop="name headline">数据结构</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2024-03-17T10:02:03.000Z" title="发表于 2024-03-17 18:02:03">2024-03-17</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2024-07-29T08:25:37.943Z" title="更新于 2024-07-29 16:25:37">2024-07-29</time></span></div><div class="meta-secondline"><span class="post-meta-separator"></span><span class="post-meta-wordcount"><i class="anzhiyufont anzhiyu-icon-file-word post-meta-icon" title="文章字数"></i><span class="post-meta-label" title="文章字数">字数总计:</span><span class="word-count" title="文章字数">12.4k</span><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-clock post-meta-icon" title="阅读时长"></i><span class="post-meta-label" title="阅读时长">阅读时长:</span><span>40分钟</span></span><span class="post-meta-separator"></span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构"><i class="anzhiyufont anzhiyu-icon-fw-eye post-meta-icon"></i><span class="post-meta-label" title="阅读量">阅读量:</span><span id="busuanzi_value_page_pv"><i class="anzhiyufont anzhiyu-icon-spinner anzhiyu-spin"></i></span></span><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为江苏/徐州"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>江苏/徐州</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729161024495.png"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><header><a class="post-meta-categories" href="/categories/408/" itemprop="url">408</a><a href="/tags/408/" tabindex="-1" itemprop="url">408</a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" tabindex="-1" itemprop="url">数据结构</a><h1 id="CrawlerTitle" itemprop="name headline">数据结构</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">11andyy</span><time itemprop="dateCreated datePublished" datetime="2024-03-17T10:02:03.000Z" title="发表于 2024-03-17 18:02:03">2024-03-17</time><time itemprop="dateCreated datePublished" datetime="2024-07-29T08:25:37.943Z" title="更新于 2024-07-29 16:25:37">2024-07-29</time></header><h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="绪论"><a href="#绪论" class="headerlink" title="绪论"></a>绪论</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">    绪论--&gt;数据结构</span><br><span class="line">    绪论--&gt;五个特征</span><br><span class="line">    </span><br><span class="line">    数据结构--&gt;逻辑结构</span><br><span class="line">    数据结构--&gt;物理结构</span><br><span class="line">    数据结构--&gt;数据运算</span><br><span class="line">    </span><br><span class="line">    五个特征--&gt;算法定义</span><br><span class="line">    五个特征--&gt;五个特性</span><br><span class="line">    五个特征--&gt;效率的度量</span><br><span class="line">    </span><br><span class="line">    逻辑结构--&gt;block2</span><br><span class="line">    逻辑结构--&gt;block3</span><br><span class="line">    </span><br><span class="line">   	block1[&quot;有穷性、确定性、可行性、输入、输出&quot;]</span><br><span class="line">    五个特性--&gt;block1</span><br><span class="line">    效率的度量--&gt;时间复杂度</span><br><span class="line">    效率的度量--&gt;空间复杂度</span><br><span class="line">    </span><br><span class="line">    block2[&quot;线性结构：线性表、栈、队列&quot;]</span><br><span class="line">    block3[&quot;非线性结构：树、图、集合&quot;]</span><br><span class="line">    </span><br><span class="line">  </span><br></pre></td></tr></table></figure>



<h3 id="数据结构的基本概念"><a href="#数据结构的基本概念" class="headerlink" title="数据结构的基本概念"></a>数据结构的基本概念</h3><h4 id="数据结构的三要素"><a href="#数据结构的三要素" class="headerlink" title="数据结构的三要素"></a>数据结构的三要素</h4><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162300419.png" alt="image-20240729162300419"></p>
<ol>
<li>逻辑结构<ol>
<li>线性结构：线性表（1对1）</li>
<li>非线性结构：集合（同属于一个集合）、树（1对多）、图（多对多）</li>
</ol>
</li>
<li>存储结构（物理结构）<ol>
<li>顺序存储：<strong>逻辑上相邻</strong>的元素存储在物<strong>理位置上也相邻</strong>的存储单元中；优：随机存取、每个元素占空间少 缺：只能使用相邻的整块存储单元，产生较多外部碎片</li>
<li>链式存储：不要求逻辑上相邻的元素在物理位置上也相邻，借助<strong>指针</strong>来表示元素之间的逻辑关系；优：不会出现外部碎片 缺：指针占用额外的存储空间，只能实现顺序存取</li>
<li>索引存储：存储信息元素同时建立附加的<strong>索引表</strong>，索引表中的每项为<strong>索引项（关键字+地址）</strong>优：检索快 缺：索引表占用额外空间，增删数据需要修改索引表</li>
<li>散列存储（哈希存储）：根据元素的<strong>关键字</strong>直接<strong>计算存储地址</strong> 优：检索、增加、删除节点速度快 缺：散列函数不好，会产生冲突</li>
</ol>
</li>
<li>数据的运算</li>
</ol>
<h3 id="算法和算法评价"><a href="#算法和算法评价" class="headerlink" title="算法和算法评价"></a>算法和算法评价</h3><h4 id="算法效率的度量"><a href="#算法效率的度量" class="headerlink" title="算法效率的度量"></a>算法效率的度量</h4><h5 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h5><p>一个语句的<strong>频度</strong>是指该语句在算法中被重复执行的次数。所有语句的频度之和为$T(n)$，他是该算法问题规模$n$的函数，时间复杂度主要分析$T(n)$的数量级。<strong>算法中最深层循环内的语句的频度与$T(n)$ 同数量级，因此通常采用最深层循环内的语句的频度$f(n)$来分析算法的时间复杂度</strong>。因此时间复杂度为$T(n) &#x3D; O(f(n))$</p>
<p>上式中$O$的含义是$T(n)$的数量级，表示同阶，同等数量级<br>$$<br>T(n) &#x3D; O(f(n)) \iff \lim_{n \to \infty} \frac{T(n)}{f(n)} &#x3D; k<br>$$</p>
<p><strong>数量级比较：</strong><br>$$<br>O(1) \lt O(\log_2{n}) \lt O(n) \lt O(n\log_2{n}) \lt O(n^2) \lt O(n^3) \lt O(2^n) \lt O(n!) \lt O(n^n)<br>$$</p>
<p><strong>主定理求时间复杂度</strong></p>
<p>形如：<br>$$<br>T(n) &#x3D; aT(\frac{n}{b}) + f(n)\<br>$$<br>$n^{\log_{a}{b}}$与$f(n)$比较</p>
<ol>
<li>$n^{\log_{a}{b}} \lt f(n)$: $O(f(n))$</li>
<li>$n^{\log_{a}{b}} \gt f(n)$: $O(n^{\log_{a}{b}})$</li>
<li>$ n^{\log_{a}{b}} &#x3D; f(n)$: $O(n^{\log_{a}{b}}\log_2{n})$</li>
</ol>
<h5 id="空间复杂度"><a href="#空间复杂度" class="headerlink" title="空间复杂度"></a>空间复杂度</h5><p>算法的空间复杂度$S(n)$定义为该算法所需要的存储空间，它是问题规模为$n$的函数，记为：<br>$$<br>S(n) &#x3D; O(g(n))<br>$$<br>只需要关注<strong>存储空间的大小和与问题规模相关的变量</strong></p>
<h3 id="Q-A"><a href="#Q-A" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li><p>用循环比递归的效率高吗？</p>
<p> 循环和递归两者是可以互换的，不能决定性的说循环的效率比递归高</p>
<p> 递归的优点是：代码清晰，容易检查正确性；缺点是：当递归调用的次数较多时，要增加额外的堆栈处理，有可能产生堆栈溢出的情况</p>
<p> 循环的优点是：结构简单，速度快；缺点是：它不能解决全部的问题，有的问题适合用递归来解决，不适合用循环</p>
</li>
<li><p>贪心法，动态规划法以及分治法的区别？</p>
<p> <strong>贪心算法</strong>顾名思义就是做出当前来看是最好的结果，它不从整体上加以考虑，也就是<strong>局部最优解</strong>。贪心从上往下，从顶部一步一步最优，得到最后的结果，它不能保证全局最优解，与贪心选择的策略有关</p>
<p> <strong>动态规划法</strong>把问题分解成子问题，这些子问题可能有重复，可以<strong>记录</strong>下前面的子问题的结果防止重复计算，前一个子问题对后一个子问题产生一定的影响。</p>
<p> <strong>分治法</strong>将原问题划分为n个小规模的子问题，<strong>递归的</strong>解决这些子问题，然后再<strong>合并</strong>子问题的解，就是原问题的解</p>
</li>
</ol>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	线性表--&gt;顺序存储</span><br><span class="line">	线性表--&gt;链式存储</span><br><span class="line">	</span><br><span class="line">	顺序存储--&gt;顺序表</span><br><span class="line">	链式存储--&gt;单链表</span><br><span class="line">	链式存储--&gt;双链表</span><br><span class="line">	链式存储--&gt;循环链表</span><br><span class="line">	block[&quot;静态链表（借助数组实现）&quot;]</span><br><span class="line">	链式存储--&gt;block</span><br></pre></td></tr></table></figure>



<h3 id="线性表的基本定义和基本操作"><a href="#线性表的基本定义和基本操作" class="headerlink" title="线性表的基本定义和基本操作"></a>线性表的基本定义和基本操作</h3><h4 id="线性表的定义"><a href="#线性表的定义" class="headerlink" title="线性表的定义"></a>线性表的定义</h4><p>线性表是具有<strong>相同数据类型</strong>的n个数据的<strong>有限序列</strong>，除第一个元素和最后一个元素，每个元素都有一个<strong>直接前驱</strong>和<strong>直接后继</strong></p>
<h4 id="线性表的基本操作"><a href="#线性表的基本操作" class="headerlink" title="线性表的基本操作"></a>线性表的基本操作</h4><ol>
<li><code>InitList(&amp;L)</code>：初始化</li>
<li><code>Length(L)</code>：表长</li>
<li><code>LoacteElem(L, e)</code>：按值查找，返回位置</li>
<li><code>GetElem(L, i)</code>：按位置查找，返回值</li>
<li><code>ListInsert(&amp;L, i, e)</code>：插入元素</li>
<li><code>ListDelete(&amp;L, i, &amp;e)</code>：删除元素</li>
<li><code>PrintList(L)</code>：打印表</li>
<li><code>Empty(L)</code>：判空</li>
<li><code>DestoryList(&amp;L)</code>：销毁表</li>
</ol>
<h3 id="顺序表和链表的比较"><a href="#顺序表和链表的比较" class="headerlink" title="顺序表和链表的比较"></a>顺序表和链表的比较</h3><ol>
<li><p>存取方式</p>
<p> 顺序表可以顺序存取也可以随机存取，链表只能从表头顺序存取元素。例如在第i个位置上执行存&#x2F;取操作，顺序表仅需一次访问，而链表需要从头访问</p>
</li>
<li><p>物理结构</p>
<p> 都是线性结构，顺序表：逻辑上相邻的元素，存储的物理位置也相邻；链表：逻辑上相邻的元素，存储物理位置不一定相邻</p>
</li>
<li><p>查找、插入、删除操作</p>
<p> 对于按值查找，顺序表无序时，两者时间复杂度都是$O(n)$；顺序表有序时，二分查找，时间复杂度为$O(logn)$</p>
<p> 对于按序号查找，顺序表时间复杂度为$O(1)$，链表的时间复杂度为$O(n)$</p>
<p> 对于插入删除操作，顺序表需要<strong>平均移动半个表长</strong>，链表只需要修改指针即可</p>
</li>
<li><p>空间分配</p>
<p> 顺序表在静态存储空间分配下一旦装满就不能扩充；预先分配过大造成浪费，过小造成溢出。</p>
<p> 链表只需要在需要时申请分配，只要内存有空间就可以分配</p>
</li>
</ol>
<h3 id="Q-A-1"><a href="#Q-A-1" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li><p>头指针和头节点的区别？</p>
<p> <strong>头指针：</strong>指向第一个节点存储位置的指针，具有标识作用，无论链表为空，头指针必须存在</p>
<p> <strong>头节点：</strong>是放在第一个元素的节点之前，<strong>便于在第一个元素之前进行插入和删除操作</strong>，头节点不是链表的必须元素可有可无，数据域也不存放任何信息</p>
</li>
<li></li>
</ol>
<h2 id="栈、队列、数组"><a href="#栈、队列、数组" class="headerlink" title="栈、队列、数组"></a>栈、队列、数组</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	线性表--操作受限--&gt;栈</span><br><span class="line">	栈--&gt;顺序栈</span><br><span class="line">	栈--&gt;链栈</span><br><span class="line">	栈--&gt;共享栈</span><br><span class="line">	线性表--操作受限--&gt;队列</span><br><span class="line">	队列--&gt;顺序队列</span><br><span class="line">	队列--&gt;链式队列</span><br><span class="line">	队列--&gt;双端队列</span><br><span class="line">	队列--&gt;循环队列</span><br><span class="line"></span><br><span class="line">	线性表--推广--&gt;数组</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><h4 id="栈的基本概念"><a href="#栈的基本概念" class="headerlink" title="栈的基本概念"></a>栈的基本概念</h4><p>栈（stack）只允许<strong>在一端进行插入和删除的线性表</strong></p>
<h4 id="顺序栈、链栈、共享栈"><a href="#顺序栈、链栈、共享栈" class="headerlink" title="顺序栈、链栈、共享栈"></a>顺序栈、链栈、共享栈</h4><p>顺序栈：后进先出</p>
<p>链栈：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162336164.png" alt="image-20240729162336164"></p>
<p>共享栈：利用<strong>栈底相对位置不变的特性</strong>，可以让两个顺序栈共享一个一维数组空间，将两个共享栈的栈底设置为两端，栈顶指针向中间靠拢</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162344208.png" alt="image-20240729162344208"></p>
<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><h4 id="队列的基本概念"><a href="#队列的基本概念" class="headerlink" title="队列的基本概念"></a>队列的基本概念</h4><p>队列（queue）只允许在<strong>一端插入</strong>，在<strong>另一端删除</strong></p>
<h4 id="顺序队列、链式对联、双端队列、循环队列"><a href="#顺序队列、链式对联、双端队列、循环队列" class="headerlink" title="顺序队列、链式对联、双端队列、循环队列"></a>顺序队列、链式对联、双端队列、循环队列</h4><p>顺序队列：先进先出，<strong>队头指针，队尾指针</strong>，存在假溢出现象</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162348818.png" alt="image-20240729162348818"></p>
<p>链式队列：</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162408215.png" alt="image-20240729162408215"></p>
<p>循环队列：将队列臆造为一个环状空间，利用除法取余解决溢出问题</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162353069.png" alt="image-20240729162353069"></p>
<p>双端队列：允许两端都可以插入和删除的线性表</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162358544.png" alt="image-20240729162358544"></p>
<h3 id="栈和队列的应用"><a href="#栈和队列的应用" class="headerlink" title="栈和队列的应用"></a>栈和队列的应用</h3><h4 id="栈在括号匹配中的算法思想"><a href="#栈在括号匹配中的算法思想" class="headerlink" title="栈在括号匹配中的算法思想"></a>栈在括号匹配中的算法思想</h4><ol>
<li>凡是出现左括号，则进栈</li>
<li>凡是出现右括号<ol>
<li>首先检查栈是否空？若空，则右括号多余</li>
<li>否则和栈顶元素进行比较，若相匹配，则栈顶左括号出栈</li>
</ol>
</li>
<li>表达式检验结束<ol>
<li>若栈空，则匹配正确</li>
<li>否则说明左括号有多余</li>
</ol>
</li>
</ol>
<h4 id="栈在后缀表达式求值中的算法思想"><a href="#栈在后缀表达式求值中的算法思想" class="headerlink" title="栈在后缀表达式求值中的算法思想"></a>栈在后缀表达式求值中的算法思想</h4><p>中缀转后缀：</p>
<ol>
<li>按运算顺序加括号</li>
<li>将运算符移动至对应右括号的前面</li>
<li>除去所有的括号</li>
</ol>
<p>计算机中缀转后缀：</p>
<ol>
<li><p>遇到操作数，直接加入后缀表达式</p>
</li>
<li><p>遇到左括号，直接入栈，遇到右括号，依次弹出栈中的运算符，加入后缀表达式，直到弹出左括号。（<strong>左括号删除，不加入后缀表达式</strong>）</p>
</li>
<li><p>遇到运算符，优先级高于栈顶或（，入栈，低于栈顶，一直出栈直至高于，然后把当前符号入栈</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162429366.png" alt="image-20240729162429366"></p>
</li>
</ol>
<p>顺序扫描表达式的每一项，根据它的类型做出相应的操作：</p>
<ol>
<li>若是操作数。压栈</li>
<li>若是操作符，从栈顶退出两个操作数<strong>y x</strong>， 形成运算指令 <strong>x y</strong>，将结果重新压栈</li>
<li>表达式求完，栈顶的数就是结果</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162437699.png" alt="image-20240729162437699"></p>
<h4 id="栈在递归中的应用"><a href="#栈在递归中的应用" class="headerlink" title="栈在递归中的应用"></a>栈在递归中的应用</h4><p>递归算法转换为非递归算法，通常需要借助栈来实现</p>
<h4 id="队列在层次遍历中的应用"><a href="#队列在层次遍历中的应用" class="headerlink" title="队列在层次遍历中的应用"></a>队列在层次遍历中的应用</h4><p>二叉树的层次遍历：每次队头出队，扩展队头，直到队空</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162441967.png" alt="image-20240729162441967"></p>
<h4 id="队列在计算机系统中的应用"><a href="#队列在计算机系统中的应用" class="headerlink" title="队列在计算机系统中的应用"></a>队列在计算机系统中的应用</h4><ol>
<li><p>解决主机与外部设备之间速度不匹配的问题</p>
<p> （以主机和打印机为例）主机输出数据给打印机打印，输出数据的速度比打印机快得多，若直接把输出数据送给打印机显然不行，解决的方法是设置一个<strong>打印缓冲区</strong>，主机把打印数据写入这个缓冲区，写满后就<strong>暂停输出</strong>，打印机从缓冲区按照<strong>先进先出</strong>的原则进行打印，打印完后<strong>向主机发出请求</strong>，主机再把数据写入缓冲区。保证的打印的数据准确由提高了主机的效率。由此可见，打印数据缓冲区中所存储的数据就是一个队列。</p>
</li>
<li><p>解决由多用户引起的资源竞争问题</p>
<p> （以CPU的资源竞争为例）在一个多终端的计算机上，多个用户需要CPU运行程序，通过各自的终端提出占用CPU的请求。操作系统<strong>按照请求的时间先后顺序，把他们排成一个对立，每次把CPU分给队首用户使用</strong>，当用户程序执行完毕或者是分配的CPU时间片用完，令其出队，再把CPU给新的队首使用。</p>
</li>
</ol>
<h3 id="数组和特殊矩阵"><a href="#数组和特殊矩阵" class="headerlink" title="数组和特殊矩阵"></a>数组和特殊矩阵</h3><h4 id="数组的存储方式"><a href="#数组的存储方式" class="headerlink" title="数组的存储方式"></a>数组的存储方式</h4><p><strong>按行优先</strong>存储和<strong>按列优先</strong>存储</p>
<h4 id="特殊矩阵"><a href="#特殊矩阵" class="headerlink" title="特殊矩阵"></a>特殊矩阵</h4><p>对称矩阵、三角矩阵、稀疏矩阵</p>
<h3 id="Q-A-2"><a href="#Q-A-2" class="headerlink" title="Q&amp;A"></a>Q&amp;A</h3><ol>
<li><p>如何区分循环队列是空还满</p>
<p> 普通情况下，循环队列队空和队满的条件一样  <code>q.front == q.rear</code></p>
<p> ps:队头指针指向第一个数，队尾指针指向最后一个数的下一个位置，即<strong>即将入队的位置</strong></p>
<p> 法1：牺牲一个存储单元来区分队空和队满 <code>( q.rear + 1 ) % Max_size == q.front</code> </p>
<p> 法2：增设标识元素个数的数据成员 队空 <code>q.size == 0</code>  队满 <code>q.size == Max_size</code> </p>
</li>
<li></li>
</ol>
<h2 id="串"><a href="#串" class="headerlink" title="串"></a>串</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	block1[&quot;基本概念：主串、子串、串长&quot;]</span><br><span class="line">	串--&gt;block1</span><br><span class="line"> 	串--&gt;存储结构</span><br><span class="line"> 	block2[&quot;定长顺序存储</span><br><span class="line"> 			堆分配存储</span><br><span class="line"> 			块链存储&quot;]</span><br><span class="line"> 	存储结构--&gt;block2</span><br><span class="line"> 	串--&gt;模式匹配算法</span><br><span class="line"> 	模式匹配算法--&gt;暴力匹配</span><br><span class="line"> 	模式匹配算法--next数组--&gt;KMP</span><br><span class="line"> 	模式匹配算法--nextval数组--&gt;KMP算法的改进</span><br></pre></td></tr></table></figure>

<h3 id="串的模式匹配"><a href="#串的模式匹配" class="headerlink" title="串的模式匹配"></a>串的模式匹配</h3><p>求模式串在子串中的位置</p>
<h2 id="树与二叉树"><a href="#树与二叉树" class="headerlink" title="树与二叉树"></a>树与二叉树</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	树--&gt;二叉树</span><br><span class="line">	树--&gt;树和森林</span><br><span class="line">	</span><br><span class="line">	b1[&quot;概念：定义、存储结构&quot;]</span><br><span class="line">	b2[&quot;概念：定义、存储结构&quot;]</span><br><span class="line">	二叉树--&gt;b1</span><br><span class="line">	二叉树--&gt;操作</span><br><span class="line">	操作--&gt;三种遍历</span><br><span class="line">	操作--&gt;线索二叉树</span><br><span class="line">	二叉树--&gt;应用</span><br><span class="line">	应用--&gt;排序二叉树</span><br><span class="line">	排序二叉树--&gt;平衡二叉树</span><br><span class="line">	应用--&gt;哈夫曼树</span><br><span class="line">	树和森林--&gt;b2</span><br><span class="line">	b3[&quot;操作&quot;]</span><br><span class="line">	b4[&quot;应用&quot;]</span><br><span class="line">	树和森林--&gt;b3</span><br><span class="line">	树和森林--&gt;b4</span><br><span class="line">	b3--&gt;遍历</span><br><span class="line">	b3--&gt;与二叉树的转换</span><br><span class="line">	b4--&gt;并查集</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<h3 id="树和二叉树的基本概念"><a href="#树和二叉树的基本概念" class="headerlink" title="树和二叉树的基本概念"></a>树和二叉树的基本概念</h3><ol>
<li><p><strong>树</strong>：树是非线性结构，节点之间有明显的<strong>层次关系</strong>。根节点没有前驱，除根结点每个节点有且只有一个前驱；叶节点没有后继，除叶节点每个节点有多个后继</p>
<p> 递归定义：</p>
<p> a.或者为空树</p>
<p> b.或者由一个根节点和$m$个不相交的被称为根的有限集$T_1,T_2,…,T_m$子树组成。每个集合又是一棵树。</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162501171.png" alt="image-20240729162501171"></p>
<p> <strong>祖先</strong>（根到某个节点路径上的所有节点）、<strong>子孙</strong>（某个节点下面的所有节点）、<strong>双亲</strong>（父节点）、<strong>孩子</strong>（子节点）、<strong>兄弟</strong>（相同父节点的子节点）、<strong>堂兄弟</strong>（双亲在同一层的子节点）</p>
<p> <strong>节点的度</strong>：孩子节点的个数； <strong>树的度</strong>：节点的最大度数</p>
<p> <strong>分支节点</strong>：度大于0的节点；<strong>叶子节点</strong>：度为0的节点</p>
<p> <strong>节点层次</strong>：节点所在的层的深度（根为1） <strong>树高度</strong>：节点的最大层数  <strong>节点的高度</strong>：以该节点为根的子树的高度</p>
<p> <strong>有序树</strong>：各个子树不能交换 <strong>路径</strong>：两个节点路径序列 <strong>路径长度</strong>：两个节点路径的边数</p>
</li>
<li><p><strong>二叉树</strong>：二叉树每个节点<strong>最多有两颗子树</strong>，并且二叉树的子树有左右之分，次序不能任意颠倒</p>
<p> 递归定义：</p>
<p> a.或者为空二叉树</p>
<p> b.或者由一个根节点和两个互不相交的被称为根的左子树和右子树组成。左子树和右子树又分别为二叉树。</p>
</li>
<li><p><strong>满二叉树</strong>：除了叶子节点，每个节点均有两棵子树</p>
<p> 特点：高度为$h$，有$2^h-1$个节点，根节点编号为1，左孩子为$2i$，右孩子为$2i+1$，双亲为$\lfloor i&#x2F;2 \rfloor$</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162507031.png" alt="image-20240729162507031"></p>
</li>
<li><p><strong>完全二叉树</strong>：除了最后一层外，其他任何一层的节点数均达到最大值，<strong>且最后一层也只是在最右侧缺少节点</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162511600.png" alt="image-20240729162511600"></p>
</li>
<li><p><strong>二叉排序树</strong>：左子树关键字小于根节点，右子树关键字大于根节点；左子树和右子树又分别是二叉排序树</p>
</li>
<li><p><strong>平衡二叉树</strong>：树中任意一个节点的左子树和右子树高低之差的<strong>绝对值不超过1</strong></p>
</li>
<li><p><strong>正则二叉树</strong>：每个分支节点的出度为$m$，当$m&#x3D;2$是满二叉树</p>
</li>
<li><p><strong>森林</strong>：不相交的树的集合</p>
</li>
</ol>
<h3 id="树和二叉树的性质"><a href="#树和二叉树的性质" class="headerlink" title="树和二叉树的性质"></a>树和二叉树的性质</h3><ol>
<li><p>树的节点数等于所有节点的度数之和+1</p>
<p> 节点的度数等于节点的孩子数，最后在加上根节点</p>
</li>
<li><p><strong>非空二叉树上的叶子节点数&#x3D;度为2的节点数+1，$n_0&#x3D;n_2+1$</strong></p>
<p> 证明：$n&#x3D;n_0+n_1+n_2$</p>
<p> 分支数 $B &#x3D; n_1 + 2n_2$</p>
<p> $n &#x3D; B + 1$，得到  $n_0&#x3D;n_2+1$</p>
</li>
<li><p>非空二叉树的第$k$层最多有$2^{k-1}$个节点</p>
</li>
<li><p>高度为$h$的二叉树最多有$2^h-1$个节点</p>
</li>
<li><p>对于完全二叉树从上到下，从左到右编号$1,2,…,n$</p>
<ol>
<li>若$i ≤ \lfloor n&#x2F; 2 \rfloor$，则节点$i$为分支节点，即最后一个分支节点的编号是$\lfloor n&#x2F;2 \rfloor$</li>
<li>度为1的节点只可能是最后一个分支节点</li>
<li>$i$的双亲节点为$\lfloor i &#x2F;2 \rfloor$</li>
<li>节点$i$所在的层次（深度）为 $\lfloor log_i +1\rfloor$</li>
</ol>
</li>
<li><p>具有$n$个节点的完全二叉树的高度为$\lceil\log_2(n+1)\rceil$ 或  $\lfloor\log_2n\rfloor+1$</p>
<p> 证明：根据完全二叉树的定义<br> $$<br> 2^{h-1}-1＜n≤2^h - 1 \ or \ 2^{h-1} ≤ n ＜ 2^h\<br> h - 1＜ log(n + 1) ≤ h \ or \ h - 1 ≤ logn ＜ h<br> $$<br> $h$为整数，$h &#x3D; \lceil\log_2(n+1)\rceil$或者 $h &#x3D; 1 + \lfloor logn \rfloor$</p>
</li>
</ol>
<h3 id="树的存储结构"><a href="#树的存储结构" class="headerlink" title="树的存储结构"></a>树的存储结构</h3><ol>
<li><p>双亲表示法</p>
<p> 采用顺序存储结构，每个节点增设伪指针，值为双亲的存储下标</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162517818.png" alt="image-20240729162517818"></p>
</li>
<li><p>孩子表示法</p>
<p> 每个节点的孩子表示为一个线性表（以单链表为存储结构），头指针组成线性表（以顺序表为存储结构）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729162521990.png" alt="image-20240729162521990"></p>
</li>
<li><p>孩子兄弟表示法（二叉树表示法）</p>
<p> 以二叉链表作为树的存储结构。每个节点包括：节点值、指向节点第一个孩子的指针、指向孩子下一个兄弟的指针，<strong>孩子兄弟表示法可以作为将普通树转化为二叉树的最有效方法</strong>，简记为<strong>左儿子，右兄弟</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606213300223.png" alt="image-20240606213300223"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/14133641I-2.gif" alt="孩子兄弟表示法示意图"></p>
</li>
</ol>
<h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><ol>
<li><p>顺序存储结构</p>
<p> 数组下标为二叉树节点的编号 $i,2i,2i+1$，<strong>建议数组下标从1开始</strong></p>
</li>
<li><p>链式存储结构</p>
<p> 数据域、指针域</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606185405840.png" alt="image-20240606185405840"></p>
</li>
</ol>
<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><ol>
<li><p>dfs遍历</p>
<p> 二叉树的先序中序后序，实际上就是看<strong>先根、中根、后根</strong></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="built_in">print</span>(u);<span class="comment">//先根</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">2</span>*u);</span><br><span class="line">	<span class="built_in">print</span>(u);<span class="comment">//中根</span></span><br><span class="line">	<span class="built_in">dfs</span>(<span class="number">2</span>*u<span class="number">+1</span>);</span><br><span class="line">	<span class="built_in">print</span>(u);<span class="comment">//后根</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p>层次遍历bfs</p>
<ol>
<li>根节点入队</li>
<li>取出队头</li>
<li>扩展队头入队</li>
</ol>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606185912980.png" alt="image-20240606185912980"></p>
</li>
<li><p><strong>由遍历序列构造二叉树</strong></p>
<p> 中序遍历+else可以得到唯一的二叉树</p>
<p> <strong>中序+先序：</strong> 中序（BC<strong>A</strong>EDGHFI） 先序（<strong>A</strong>BCDEFGHI）先序是走根，中序把根分为了左右，左侧为左子树，右侧为右子树，然后递归分析下去</p>
<p> <strong>中序+后序： <strong>中序（BC</strong>A</strong>EDGHFI） 后序（CBEHGIFD<strong>A</strong>）后序最后一个节点是根</p>
<p> <strong>中序+层次：</strong> 层序遍历中，第一个节点一定是根节点，将中序序列分割成了，左子树的中序序列和右子树的中序序列。若存在左子树，则层序序列的第二个节点一定是左子树的根，可以进一步划分左子树</p>
</li>
</ol>
<h3 id="树和森林的遍历"><a href="#树和森林的遍历" class="headerlink" title="树和森林的遍历"></a>树和森林的遍历</h3><ol>
<li><p>树的遍历</p>
<ol>
<li>先根遍历</li>
<li>后根遍历</li>
<li>层次遍历</li>
</ol>
</li>
<li><p>森林的遍历</p>
<ol>
<li><p>先序遍历森林</p>
<p> 访问第一棵树的根节点；先序遍历<strong>第一棵树中根节点的子树森林</strong>；再访问森林中的其他树组成的森林</p>
<p> 先序遍历森林&#x3D;对森林组成的二叉树的先序遍历&#x3D;<strong>对各个树先序遍历</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606221658467.png" alt="image-20240606221658467"></p>
</li>
<li><p>中序遍历森林</p>
<p> 中序遍历<strong>第一棵树中根节点的子树森林</strong>；访问第一棵树的根节点；中序遍历其他的树组成的森林</p>
<p> 中序遍历森林&#x3D;&#x3D;&#x3D;对森林组成的二叉树的中序遍历&#x3D;<strong>对各个树后序遍历</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606221719738.png" alt="image-20240606221719738"></p>
</li>
</ol>
</li>
</ol>
<p>&#x3D;&#x3D;最靠谱的方法&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;把森林转为二叉树，左孩子、右兄弟，先序遍历or中序遍历&#x3D;&#x3D;</p>
<h3 id="线索二叉树（没学）"><a href="#线索二叉树（没学）" class="headerlink" title="线索二叉树（没学）"></a>线索二叉树（没学）</h3><ol>
<li>定义：以一定的规则将二叉树的节点排成一个线性序列，从而得到几种遍历序列，使得该序列中的每个节点都有一个直接前驱和直接后继（首位节点除外） <strong>理解就是把树变成线性表</strong></li>
</ol>
<h3 id="树、二叉树、森林的转换"><a href="#树、二叉树、森林的转换" class="headerlink" title="树、二叉树、森林的转换"></a>树、二叉树、森林的转换</h3><ol>
<li><p>树转为二叉树</p>
<p> <strong>左儿子，右兄弟</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606213748103.png" alt="image-20240606213748103"></p>
</li>
<li><p>森林转换为二叉树</p>
<ol>
<li>先将每棵树转为二叉树</li>
<li>因为每棵<strong>转换后二叉树的右儿子必空</strong>，因此用另一棵二叉树作为右儿子</li>
</ol>
</li>
<li><p>二叉树转为森林</p>
<ol>
<li>每次都将二叉树的根和左子树组在一起和右子树分开，直到右子树不能再分</li>
<li>再把每棵二叉树转为树，就得到了原始的森林</li>
</ol>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606215617976.png" alt="image-20240606215617976"></p>
</li>
</ol>
<h3 id="树和二叉树的应用"><a href="#树和二叉树的应用" class="headerlink" title="树和二叉树的应用"></a>树和二叉树的应用</h3><h4 id="哈夫曼树和哈夫曼编码"><a href="#哈夫曼树和哈夫曼编码" class="headerlink" title="哈夫曼树和哈夫曼编码"></a>哈夫曼树和哈夫曼编码</h4><ol>
<li><p>WPL：带权路径长度之和</p>
</li>
<li><p>哈夫曼树的构造</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240606222719953.png" alt="image-20240606222719953"></p>
</li>
<li><p>哈夫曼编码：左0右1</p>
</li>
</ol>
<h4 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h4><p>详见算法</p>
<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	图--&gt;图的定义</span><br><span class="line">	图--&gt;图的存储</span><br><span class="line">	图--&gt;图的遍历</span><br><span class="line">	图--&gt;图的应用</span><br><span class="line">	</span><br><span class="line">	图的存储--&gt;邻接矩阵</span><br><span class="line">	图的存储--&gt;邻接表</span><br><span class="line">	</span><br><span class="line">	图的遍历--&gt;DFS</span><br><span class="line">	图的遍历--&gt;BFS</span><br><span class="line">	</span><br><span class="line">	a1[&quot;最小生成树：Kruskal Prim&quot;]</span><br><span class="line">	a2[&quot;最短路径：Dijkstral Floyd&quot;]</span><br><span class="line">	a3[&quot;拓扑排序：AOV网&quot;]</span><br><span class="line">	a4[&quot;关键路径：AOE网&quot;]</span><br><span class="line">	图的应用--&gt;a1</span><br><span class="line">	图的应用--&gt;a2</span><br><span class="line">	图的应用--&gt;a3</span><br><span class="line">	图的应用--&gt;a4</span><br></pre></td></tr></table></figure>

<h3 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h3><ol>
<li><p>图的定义：顶点集和边集组成$G&#x3D;(V,E)$，$V(G)&#x3D;{v_1,V_2,…,v_n},E&#x3D;{(u,v)}$</p>
</li>
<li><p>各种图：</p>
<ol>
<li>有向图、无向图</li>
<li>简单图：不存在重边和自环</li>
<li>完全图(简单完全图)：有$\frac {n(n-1)}{2}$条边的无向图或者$n(n-1)$条边的有向图称为完全图</li>
<li>子图：两个图$G,G’$,$V’$是$V$的子集，$E’$是$E’$的子集。若有满足$V(G’)&#x3D;V(G)$的子图，则称$G’$为$G$的生成子图，（点全部包括）</li>
<li>连通、连通图和连通分量<ol>
<li>连通：从v到w有路径，则v到w连通</li>
<li>连通图：任意两个点都有路径</li>
<li>连通分量：<strong>无向图</strong>的极大<strong>连通子图</strong>，称为连通分量</li>
<li>强连通图，强连通分量：v到w有路径，w到v有路径，则是强连通。<strong>有向图</strong>的极大<strong>强连通子图</strong>称为强连通分量</li>
</ol>
</li>
<li>生成树、生成森林<ol>
<li>生成树：连通图的生成树是<strong>包含图中全部顶点的一个极小连通子图</strong>，n个顶点，n-1条边</li>
<li>生成森林：在非连通图中，连通分量的生成树构成了分连通图的生成森林</li>
</ol>
</li>
</ol>
</li>
<li><p>顶点的度、入度、出度</p>
<p> 有向图的度&#x3D;入度+出度</p>
</li>
<li><p>边的权和网</p>
<p> 边上带权重的图为网</p>
</li>
<li><p>稠密图、稀疏图</p>
<p> $|E|&lt; |V|log|V|$，课视为稀疏图</p>
</li>
<li><p>路径、路径长度、回路</p>
<p> v到w路径边数为路径长度，n个顶点大于n-1条边，此图一定有环</p>
</li>
<li><p>简单路径、简单回路</p>
<p> 路径序列中，顶点不重复出现称为简单路径；回路中，除了第一个点，其余点不重复出现为简单回路</p>
</li>
<li><p>距离</p>
</li>
<li><p>有向树</p>
<p> 一个顶点的入度为0，其余顶点入度为1的有向图称为有向树</p>
</li>
</ol>
<h3 id="图的存储"><a href="#图的存储" class="headerlink" title="图的存储"></a>图的存储</h3><ol>
<li><p>邻接矩阵法（稠密图）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609102925320.png" alt="image-20240609102925320"></p>
</li>
<li><p>邻接表法（稀疏图）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609103209935.png" alt="image-20240609103209935"></p>
<p> 存储空间：无向图$O(|V|+2|E|)$，有向图$O(|V|+|E|)$</p>
</li>
<li><p>十字链表：有向图的链式存储结构</p>
<p> 每个弧有一个节点，每个顶点也是一个节点</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609103641890.png" alt="image-20240609103641890"></p>
</li>
<li><p>邻接多重表：无向图的链式存储结构</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609103655749.png" alt="image-20240609103655749"></p>
</li>
</ol>
<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><ol>
<li>深度优先搜索</li>
<li>广度优先搜索</li>
</ol>
<h3 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h3><p>一个连通图的生成树包含图的所有顶点，并且含有尽可能少的边，对于带权的连通无向图，权值之和最小的树为最小生成树</p>
<h4 id="Kruskal（稀疏图）"><a href="#Kruskal（稀疏图）" class="headerlink" title="Kruskal（稀疏图）"></a>Kruskal（稀疏图）</h4><p><code>fa[x]</code>存<code>x</code>点的父节点</p>
<ol>
<li>初始化并查集，把<code>n</code>个点放在<code>n</code>个独立的集合</li>
<li>将所有边按边权<strong>从小到大</strong>排序(贪心思想)</li>
<li>按顺序枚举每条边，如果这条边连接的两个点不在同一个集合，就把这条边加入最小生成树，并且<strong>合并</strong>这两个集合；如果这条边连接的两个点在同一个集合，就<strong>跳过</strong>，因为不能成环</li>
<li>重复执行3，直到选取了<code>n - 1</code>条边为止</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609104454613.png" alt="image-20240609104454613"></p>
<h4 id="Prim（稠密图）"><a href="#Prim（稠密图）" class="headerlink" title="Prim（稠密图）"></a>Prim（稠密图）</h4><p>算法流程类似于Dijkstra，不断选取<strong>不在圈内且距离圈最小的点</strong>，直到所有点都加入了圈</p>
<ol>
<li>初始化，所有点都不在圈内，<code>vis = 0 d[s] = 0 d[其他点] = + ∞</code></li>
<li>每次选取<strong>不在当前集合中且离圈最近的点</strong><code>u</code>，打标记加入集合</li>
<li>对<code>u</code>的所有邻点的距离执行<strong>更新操作</strong></li>
<li>重复2，3步操作，直到没有点能加入集合中</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609104534251.png" alt="image-20240609104534251"></p>
<h3 id="最短路径"><a href="#最短路径" class="headerlink" title="最短路径"></a>最短路径</h3><h4 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra"></a>Dijkstra</h4><p>时间复杂度-$O(mlogm)$</p>
<p>Dijkstra算法是基于<strong>贪心思想</strong>的<strong>单源最短路</strong>算法</p>
<p><strong>集合：</strong>已经确定好最短路的节点组成的集合</p>
<ol>
<li>初始时，所有的点都不在集合中，<code>st[i] = false</code>，<code>d[s] = 0</code>，<code>d[其他点] = +∞</code></li>
<li>迭代<code>n</code>次，每次选出<strong>不在当前集合中且离源点最近的点</strong>，将该点放入集合<code>st[t] = true</code></li>
<li>用该点进行<strong>松弛操作</strong>，更新与它相邻的点的距离</li>
</ol>
<h4 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman-Ford"></a>Bellman-Ford</h4><p><strong>Bellman-Ford</strong>算法是基于<strong>松弛操作</strong>的单源最短路算法</p>
<p><code>e[u][j]</code>存<code>u</code>点的出边的邻点和边权，<code>dist[u]</code>存<code>u</code>点到源点的距离</p>
<ol>
<li>初始化，<code>d[s] = 0, d[其他点]=+∞</code></li>
<li>执行多轮循环。每轮循环，对<strong>所有边</strong>都尝试进行一次松弛操作</li>
<li>当一轮循环中没有成功的松弛操作时，算法停止</li>
</ol>
<h4 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa"></a>Spfa</h4><p>时间复杂度-$O(km,nm)$</p>
<p>Bellman-Ford算法的优化</p>
<p>只有本轮被更新的点，其<strong>出边终点</strong>才有可能引起下一轮的松弛操作，因此用<strong>队列</strong>来维护被更新的<strong>出边终点</strong>的集合。</p>
<p><code>vis[u]</code>标记<code>u</code>点是否在队内，<code>cnt[v]</code>记录边数，判负环</p>
<ol>
<li>初始化，<code>s</code>入队，标记<code>s</code>在队内，<code>d[s] = 0 d[其他点] =  +∞</code></li>
<li>从<strong>队头</strong>弹出<code>u</code>点，标记<code>u</code>不在队内</li>
<li>枚举<code>u</code>的所有出边，进行松弛操作。记录<code>s</code>到<code>v</code>走过的边数，并判负环。如果<code>v</code>不在队内则把<code>v</code>压入队尾，并打上标记</li>
<li>重复步骤2，3，直到队内为空</li>
</ol>
<h4 id="Floyd"><a href="#Floyd" class="headerlink" title="Floyd"></a>Floyd</h4><p>时间复杂度-$O(n^3)$</p>
<p>Floyd(弗洛伊德)算法是<strong>动态规划</strong>算法，也称为插点法。是<strong>全源</strong>最短路算法</p>
<p><strong>状态表示</strong></p>
<p><code>d[k, i, j]</code>表示从<code>i</code>到<code>j</code>，且中间只经过节点编号为<code>1~k</code>的最短路径的长度</p>
<p><strong>状态计算</strong></p>
<p>路径的选择分为<strong>两类</strong></p>
<ol>
<li>路径不经过<code>k</code>点，继承原值：<code>d[k, i, j] = d[k - 1, i, j]</code></li>
<li>路径经过<code>k</code>点，松弛操作：<code>d[k, i, j] = d[k - 1, i, k] + d[k - 1, k, j]</code></li>
</ol>
<p><strong>说明</strong></p>
<ol>
<li><p>计算第<code>k</code>层的<code>d[i, j]</code>时，必须先将<code>k - 1</code>层的所有状态计算出来，所以需要把<strong>k放在最外层</strong></p>
</li>
<li><p>状态可以理解为，第<code>k - 1</code>层的二维表向第<code>k</code>层的二维表的<strong>投射</strong></p>
</li>
<li><p>两类状态都是调用的上一层，因此用滚动数组就可以优化掉</p>
</li>
</ol>
<p><strong>初始化</strong></p>
<ol>
<li><code>i≠j</code>，无边<code>d[i][j] = ∞</code>，有边<code>d[i][j] = w</code></li>
<li><code>i=j</code>，<code>d[i][j] = 0</code></li>
</ol>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	a1[&quot;基本概念：静态查找、动态查找&quot;]</span><br><span class="line">	a2[&quot;散列结构-散列表&quot;]</span><br><span class="line">	a3[&quot;效率指标-平均查找长度&quot;]</span><br><span class="line">	查找--&gt;a1</span><br><span class="line">	查找--&gt;线性结构</span><br><span class="line">	线性结构--&gt;顺序查找</span><br><span class="line">	线性结构--&gt;折半查找</span><br><span class="line">	线性结构--&gt;分块查找</span><br><span class="line">	查找--&gt;树形结构</span><br><span class="line">	树形结构--&gt;二叉排序树</span><br><span class="line">	树形结构--&gt;二叉平衡树</span><br><span class="line">	树形结构--&gt;B树</span><br><span class="line">	树形结构--&gt;B+树</span><br><span class="line">	查找--&gt;a2</span><br><span class="line">	a2--&gt;性能分析</span><br><span class="line">	查找--&gt;a3</span><br><span class="line">	a3--&gt;查找成功</span><br><span class="line">	a3--&gt;查找失败</span><br></pre></td></tr></table></figure>

<h3 id="查找的基本概念"><a href="#查找的基本概念" class="headerlink" title="查找的基本概念"></a>查找的基本概念</h3><ol>
<li><p>静态查找和动态查找：一个查找表的操作只涉及查找操作，则无需动态地修改查找表。反之，需要动态地插入和删除的查找称为动态查找，适合静态查找有：顺序查找、折半查找、散列查找；适合动态查找有二叉排序树的查找、散列查找</p>
</li>
<li><p>平均查找长度：一次查找的长度是指需要比较关键字的次数，平均查找长度是查找过程进行关键字次数比较的平均值<br> $$<br> ASL&#x3D;\sum_{i&#x3D;1}^{n}P_iC_i<br> $$<br> n是查找表的长度，$P_i$是查找第$i$个数据元素的概率，一般认为是$1&#x2F;n$，$C_i$是找到第$i$个数据元素需要进行比较的次数</p>
</li>
</ol>
<h3 id="查找类型"><a href="#查找类型" class="headerlink" title="查找类型"></a>查找类型</h3><h4 id="线形查找"><a href="#线形查找" class="headerlink" title="线形查找"></a>线形查找</h4><h5 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h5><p>从线性表的一端开始，逐个检查关键字是否符合条件，若查找的关键字符合条件，则查找成功，若查找到表的另一端，则查找失败。时间效率为$O(n)$<br>$$<br>ASL &#x3D; \frac{(1 + 2 + … + n)}n &#x3D; \frac{(1+n)n}{2n}&#x3D;\frac{1 + n}{2}<br>$$</p>
<h5 id="折半查找（二分查找）"><a href="#折半查找（二分查找）" class="headerlink" title="折半查找（二分查找）"></a>折半查找（二分查找）</h5><p>适用于所有<strong>有序的顺序表</strong></p>
<p>时间复杂度-$O(logn)$</p>
<p><strong>最大化查找–可行区在左侧</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20231203095018290.png" alt="image-20231203095018290"></p>
<p>​	</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// a[1~n]</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>; <span class="comment">// 开区间</span></span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;<span class="comment">// l + 1 = r时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &lt;= x) l = mid;</span><br><span class="line">        <span class="keyword">else</span> r = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20231203095517813.png" alt="image-20231203095517813"></p>
<p><strong>最小化查找–可行区在右侧</strong></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;<span class="comment">// a[1~n]</span></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = n + <span class="number">1</span>; <span class="comment">// 开区间</span></span><br><span class="line">    <span class="keyword">while</span>(l + <span class="number">1</span> &lt; r)&#123;<span class="comment">// l + 1 = r时结束</span></span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(a[mid] &gt;= x) r = mid;</span><br><span class="line">        <span class="keyword">else</span> l = mid;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<ol>
<li>指针跳跃的次数为$logn$</li>
<li>指针指向区间的<strong>两侧外面</strong></li>
<li>$l + 1 &#x3D; r$时循环结束</li>
<li>可行区的<strong>指针最后一定指向答案</strong></li>
<li><strong>开区间可以正确处理边界</strong></li>
</ol>
<h5 id="分块查找"><a href="#分块查找" class="headerlink" title="分块查找"></a>分块查找</h5><p>先把查找表分为若干子表，要求<strong>每个子表的元素都要比它后面子表的元素小</strong>，也就是保证块间是有序的（但是子表内部不一定有序），<strong>把各个子表的最大关键字构成一张索引表，表中还含各个子表的起始地址</strong>。特点是快间有序，块内无序，查找时，<strong>块间进行索引查找，块内进行顺序查找</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609115927496.png" alt="image-20240609115927496"></p>
<h4 id="树形查找"><a href="#树形查找" class="headerlink" title="树形查找"></a>树形查找</h4><h5 id="二叉排序树（BST）"><a href="#二叉排序树（BST）" class="headerlink" title="二叉排序树（BST）"></a>二叉排序树（BST）</h5><p>查找插入删除 O(n)</p>
<p>或者是一棵空树，或者是一棵有特点的树，如果该树有左子树，左子树所有节点小于根节点，如果有右子树，右子树所有节点大于根节点；左右子树都是二叉排序树。在查找时可以进行动态插入和删除。<strong>因此对二叉排序树进行中序遍历，可以得到一个有序序列</strong></p>
<ol>
<li><p>查找</p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 伪代码</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> u)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(u!=null)&#123;</span><br><span class="line">		<span class="comment">// 比较根节点</span></span><br><span class="line">		<span class="keyword">if</span>(x == u.data) <span class="keyword">return</span> u;</span><br><span class="line">		<span class="comment">// 大于根节点,查找右儿子</span></span><br><span class="line">		<span class="keyword">if</span>(x &gt; u.data) <span class="built_in">find</span>(x, u.rchlid);</span><br><span class="line">		<span class="comment">// 小于根节点查找左儿子</span></span><br><span class="line">		<span class="keyword">else</span> <span class="built_in">find</span>(x, u.lchlid);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>插入</p>
<p> 若原二叉排序树为空，直接插入；</p>
<p> 关键字k小于根节点，则插入到左子树，关键字大于根节点，插入到右子树，插入的节点一定是一个新添加的叶子节点</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609121150448.png" alt="image-20240609121150448"></p>
</li>
<li><p>删除</p>
<p> 二叉排序树删除一个节点时，不能把以该节点为根的子树上的节点都删除，<strong>必须先把被删除节点从二叉排序树的链表上摘下，将因删除节点而断开的二叉链表重新连接起来</strong>，确保二叉排序树的性质不会丢失</p>
<ol>
<li><p>若删除节点是叶子节点，直接删除</p>
</li>
<li><p>若节点z只有一棵左子树或者只有一棵右子树，则让z的子树称为z父节点的子树，代替z的位置</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609123654451.png" alt="image-20240609123654451"></p>
</li>
<li><p>若节点z有左右两棵子树，则<strong>令z的直接后继（或直接前驱）代替z，然后从二叉排序树中删去这个直接后继（或直接前驱）</strong>，这样就转换成了第一种或第二种情况</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609123847158.png" alt="image-20240609123847158"></p>
</li>
</ol>
<p> 两个思路：</p>
<ol>
<li><p>修改左子树</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.找到将被删除节点的左子树中的最大值，走到左子树，一路往右下走</span><br><span class="line">2.将这个最大值保存，并删除这个节点</span><br><span class="line">3.将我们保存到的左子树最大值替换给将被删除的节点的值</span><br></pre></td></tr></table></figure>

<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609152923405.png" alt="image-20240609152923405"></p>
</li>
<li><p>修改右子树</p>
 <figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1.找到将被删除节点的右子树中的最小值，走到左子树，一路往左下走</span><br><span class="line">2.将这个最小值保存，并删除这个节点</span><br><span class="line">3.将我们保存的右子树的最小值替换给将被删除节点的值</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h5 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h5><p>查找插入删除 O(logn)</p>
<ol>
<li><p>平衡二叉树的定义：为了避免树的高度增长过快，降低二叉排序树的性能，**规定在插入和删除节点时，要保证任意节点的左右子树高度差的绝对值不超过，这样的二叉树称为平衡二叉树，也称AVL树。定义左子树的高度和右子树高度差为该节点的平衡因子，取值为-1，0，1</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609125114325.png" alt="image-20240609125114325"></p>
</li>
<li><p>插入</p>
<p> <strong>右孩子左旋，左孩子右旋</strong></p>
<p> 每当在二叉排序树插入或删除节点时其路径上的节点是否因为此次操作会导致不平衡。若导致了不平衡，<strong>则先找到插入路径上离插入节点最近的平衡因子的绝对值大于1的节点A</strong>，再对以A为根的子树，调整位置，使之平衡</p>
<p> &#x3D;&#x3D;每次调整的对象都是最小不平衡子树，即以查找路径上离插入节点最近的不平衡因子节点为根的子树&#x3D;&#x3D;</p>
<p> &#x3D;&#x3D;从插入节点，往上找&#x3D;&#x3D;</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609130344153.png" alt="image-20240609130344153"></p>
<p> 前半部分和二叉排序树一样，新节点插入以后，关注查找路径上的不平衡因子，有四种情况</p>
<ol>
<li><p>LL：在A的<strong>左孩子</strong>的<strong>左子树</strong>中插入导致不平衡</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609131644920.png" alt="image-20240609131644920"></p>
<p> &#x3D;&#x3D;BL&lt;B&lt;BR&lt;A&lt;AR&#x3D;&#x3D;</p>
<p> &#x3D;&#x3D;B向右上旋转，成为根节点，A向右下旋转成为B的右子树&#x3D;&#x3D;，其余节点，按照顺序进行排列</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609132111345.png" alt="image-20240609132111345"></p>
</li>
<li><p>RR：在A的<strong>右孩子</strong>的<strong>右子树</strong>中插入导致不平衡</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609132237497.png" alt="image-20240609132237497"></p>
<p> &#x3D;&#x3D;AL&lt;A&lt;BL&lt;B&lt;BR&#x3D;&#x3D;</p>
<p> &#x3D;&#x3D;B向左上旋转，成为根节点，A向左下旋转成为B的左子树&#x3D;&#x3D;，其余节点，按照顺序进行排列</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609132439737.png" alt="image-20240609132439737"></p>
</li>
<li><p>LR：在A的<strong>左孩子</strong>的<strong>右子树</strong>中插入导致不平衡</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609132644198.png" alt="image-20240609132644198"></p>
<p> 把BR节点拆开看，情况</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609132745876.png" alt="image-20240609132745876"></p>
<p>  问题分为两步：第一步，让C向<strong>左上</strong>旋转，代替B,让B向<strong>左下</strong>旋转成为C的左子树  （RR）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609133102078.png" alt="image-20240609133102078"></p>
<p> 第二步：让C向<strong>右上</strong>旋转，代替A，让A向<strong>右下</strong>旋转成为C的右子树 （LL）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609133244591.png" alt="image-20240609133244591"></p>
</li>
<li><p>RL：在A的<strong>右孩子</strong>的<strong>左子树</strong>中插入导致不平衡</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609133913804.png" alt="image-20240609133913804"></p>
<p> 把BL节点拆开看，情况</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609133933764.png" alt="image-20240609133933764"></p>
<p>  问题分为两步：第一步，让C向<strong>右上</strong>旋转，代替B,让B向<strong>右下</strong>旋转成为C的右子树  （LL）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609134116903.png" alt="image-20240609134116903"></p>
<p> 第二步：让C向<strong>左上</strong>旋转，代替A，让A向<strong>左下</strong>旋转成为C的左子树 （RR）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609134219666.png" alt="image-20240609134219666"></p>
<p> RR</p>
</li>
</ol>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609134801310.png" alt="image-20240609134801310"></p>
<p> ​	RL</p>
<p> 右旋</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609134944418.png" alt="image-20240609134944418"></p>
<p> 左旋</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609135142025.png" alt="image-20240609135142025"></p>
</li>
<li><p>删除</p>
<ol>
<li><p>删除节点（方法同二叉排序树）左子树的最大值或右子树的最小值代替删除的节点</p>
</li>
<li><p>一路向北找到最小不平衡树，找不到就结束了 </p>
</li>
<li><p>找最小不平衡树下。“个头最高”的<strong>儿子</strong>、<strong>孙子</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609151731036.png" alt="image-20240609151731036"></p>
</li>
<li><p>根据孙子的位置，调整平衡（LL RR LR  RL）</p>
<p> <strong>孙子在LL位置，儿子右旋</strong></p>
<p> <strong>孙子在RR位置，儿子左旋</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609152000331.png" alt="image-20240609152000331"></p>
<p> <strong>孙子在LR位置：孙子先左旋后右旋</strong></p>
<p> <strong>孙在在RL位置，孙子先右旋后左旋</strong></p>
</li>
<li><p>如果不平衡向上传导，继续2</p>
<p> 检查不平衡是否向上传导了，右侧的子树高度变矮，导致上方的节点又不平衡了</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609152538384.png" alt="image-20240609152538384"></p>
</li>
</ol>
</li>
<li><p>查找</p>
</li>
</ol>
<h5 id="红黑树（RBT）"><a href="#红黑树（RBT）" class="headerlink" title="红黑树（RBT）"></a>红黑树（RBT）</h5><p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609163428584.png" alt="image-20240609163428584"></p>
<p>&#x3D;&#x3D;左根右、根叶黑、不红红、黑路同&#x3D;&#x3D;</p>
<p>查找插入删除$ O(logn)$，avl树插入或删除会影响平衡特性，因此需要频繁调整平衡树，这就造成了时间开销变大，红黑树插入和删除，很多时候不会破坏红黑特性，无需频繁调整树的形态，即便是要调整，也能在常数级的时间内完成</p>
<ol>
<li><p>红黑树的定义：红黑树是二叉排序树，左根右；</p>
<ol>
<li><p>每个节点是红色的或是黑色的</p>
</li>
<li><p>根节点是黑色的</p>
</li>
<li><p>叶子节点（null、失败节点）是黑色的</p>
</li>
<li><p>不存在两个相邻的红节点（<strong>即红节点的父节点和孩子节点均是黑色</strong>）</p>
</li>
<li><p>对于每个节点，从该节点到任一叶节点的<strong>简单路径</strong>上，所含<strong>黑节点的数目相同</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609155227064.png" alt="image-20240609155227064"></p>
<p> 黑高：bh，从某个节点出发（<strong>不含该节点</strong>）到任一空叶节点的路径上黑节点的总数</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609155927981.png" alt="image-20240609155927981"></p>
</li>
</ol>
</li>
<li><p>红黑树的性质</p>
<ol>
<li><p>从根节点到叶节点的<strong>最长路径，不大于最短路径的2倍</strong></p>
<p> &#x3D;&#x3D;路径最长的情况是红节点穿插在每个黑节点之间&#x3D;&#x3D;，还有可能一条路径上，全是黑节点没有红节点</p>
</li>
<li><p>有n个内部节点的红黑树高度$h&lt;&#x3D;2log(n+1)$，时间复杂度$O(logn)$</p>
</li>
</ol>
</li>
<li><p>插入</p>
<ol>
<li><p>查找，确定插入的位置（同二叉排序树），插入新新节点</p>
<ol>
<li><p>新节点是根：黑色</p>
</li>
<li><p>新节点非根：红色，判断破坏不红红这个规则没</p>
</li>
<li><p>插入后满足，则结束；不满足，调整，使其重新满足红黑树定义</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609161214580.png" alt="image-20240609161214580"></p>
<ol>
<li><p>黑色的叔叔：旋转+染色</p>
<ol>
<li><p>LL：右单旋，父换爷+染色</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609161906050.png" alt="image-20240609161906050"></p>
</li>
<li><p>RR：左单旋，父换爷+染色 染色是染父和爷</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609162452507.png" alt="image-20240609162452507"></p>
</li>
<li><p>LR：左右双旋，儿换爷+染色，染色是染儿和爷</p>
</li>
<li><p>RL：右左双旋，儿换爷+染色</p>
</li>
</ol>
</li>
<li><p>红色的叔叔：染色+变新</p>
<p> <strong>叔、父、爷染色，爷节点变为新节点</strong>，用同样的逻辑判断新节点</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609162130064.png" alt="image-20240609162130064"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609163142077.png" alt="image-20240609163142077"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li><p>删除（比较难）</p>
</li>
<li><p>查找</p>
<p> 从根出发，左小右大，如果查到空叶节点，则查找失败</p>
</li>
</ol>
<h4 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h4><p><strong>五叉排序树</strong>，每个节点<strong>四个关键字</strong>，<strong>最多五个孩子</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609170410678.png" alt="image-20240609170410678"></p>
<p><strong>如何保证查找效率</strong> </p>
<p>策略：m叉查找树，规定除了根节点之外，任何节点至少有$\lceil m&#x2F;2\rceil $个分叉，至少含有$\lceil m&#x2F;2\rceil -1$个关键字</p>
<p>m叉查找树，规定任何一个节点，所有子树的高度相同。满足这些要求，就是B树，</p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609171414392.png" alt="image-20240609171414392"></p>
<h5 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h5><ol>
<li><p>定义：B树。多路平衡查找树，B树种所被允许的孩子个数的最大值称为B树的阶（分叉数的最大值）</p>
</li>
<li><p>特性：</p>
<ol>
<li><p>根节点关键字数$[1,m-1]$,分支数$[2,m]$</p>
</li>
<li><p>分支节点关键字数$[\lceil m&#x2F;2\rceil -1,m-1]$,分支数$[\lceil m&#x2F;2\rceil,m]$</p>
</li>
<li><p>分支数&#x3D;关键字数+1</p>
</li>
<li><p>所有叶子节点出现在同一个层次上，并且不带信息，<strong>可以视为查找失败的节点</strong></p>
</li>
<li><p>非叶子节点的数据结构</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240609171737656.png" alt="image-20240609171737656"></p>
</li>
</ol>
</li>
<li><p>查找</p>
<ol>
<li>在B树中查找节点</li>
<li>在节点内查找关键字</li>
</ol>
</li>
<li><p>插入</p>
<ol>
<li><p>定位。利用查找算法，找出插入关键字的终端节点（不是叶节点，虽然会查找失败）</p>
</li>
<li><p>插入。每个非根节点的关键字的个数在$\lceil m&#x2F;2\rceil -1$到$m-1$。若插入后在这个范围内，则可以插入。若大于$m-1$个，必须对节点进行分裂，<strong>插入的一定是倒数第二层的终端节点</strong></p>
<p> <strong>分裂的方法：</strong>从第$\lceil m&#x2F;2\rceil $个关键字分裂，让他成为父节点</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610104430437.png" alt="image-20240610104430437"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610104645173.png" alt="image-20240610104645173"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610104719755.png" alt="image-20240610104719755"></p>
</li>
</ol>
</li>
<li><p>删除</p>
<ol>
<li><p>若被删除的关键字在<strong>终端节点</strong>，则直接删除关键字（要注意关键字的下限是否是$\lceil m&#x2F;2\rceil -1$）</p>
</li>
<li><p>若被删除的关键字有左右子树，找它的直接前驱或者是直接后继来顶替它：走进左子树一直往右下找，或走进右子树一直往坐下找</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610105126402.png" alt="image-20240610105126402"></p>
</li>
<li><p>若删除后低于下限了</p>
<ol>
<li><p>兄弟够借：右兄弟很宽裕，用当前节点的后继、后继的后继来填补空缺</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610105421832.png" alt="image-20240610105421832"></p>
</li>
<li><p>左兄弟很宽裕，用当前节点的前驱、前驱的前驱来填补空缺</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610105611546.png" alt="image-20240610105611546"></p>
</li>
<li><p>兄弟不够借：合并兄弟以及父节点被夹的关键字</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610105829149.png" alt="image-20240610105829149"></p>
</li>
<li></li>
</ol>
</li>
</ol>
</li>
</ol>
<h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>B+树是应数据库所需而出现的一种B树的变形树，和分块查找差不多，<strong>索引表存的是最大的关键字</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610110051393.png" alt="image-20240610110051393"></p>
<ol>
<li>根节点关键字数$[1,m]$,分支数$[1,m]$</li>
<li>分支节点关键字数$[\lceil m&#x2F;2\rceil,m]$,分支数$[\lceil m&#x2F;2\rceil,m]$</li>
<li>分支数&#x3D;关键字数</li>
<li>所有的叶子节点包含全部的关键字，叶子节点<strong>按照关键字从小到大排列</strong>，并且<strong>相邻叶子节点按大小顺序互相链接</strong></li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610110239323.png" alt="image-20240610110239323"></p>
<p><strong>查找</strong></p>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610110754845.png" alt="image-20240610110754845"></p>
<p><strong>m阶B树和B+树的区别</strong></p>
<ol>
<li><p>B树n个关键字对应n+1棵子树,B+树，n个关键字对应n棵子树，</p>
</li>
<li><p>B树，  根节点关键字数$[1,m-1]$，其他节点$[\lceil m&#x2F;2\rceil-1,m-1]$</p>
</li>
<li><p>B+树，根节点关键字数$[1,m]$，其他节点$[\lceil m&#x2F;2\rceil,m]$</p>
</li>
<li><p>B树节点的关键字不会重复，包含了对应记录的存储地址</p>
</li>
<li><p>B+树叶子节点包含全部关键字，非叶节点出现的关键字在叶子节点也会出现，非叶子节点只起索引作用，不包含对应记录的存储地址</p>
</li>
<li><p>B+树非叶子节点不含存储地址，同样大小的磁盘块，可<strong>以使得一个磁盘块包含更多的关键字</strong>，B+树的阶更大，树高更矮，读磁盘数更少，查找更快</p>
</li>
</ol>
<h4 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h4><ol>
<li><p>散列表的基本概念</p>
<p> 散列表：是一种数据结构，<strong>可以根据数据元素的关键字计算出它在散列表中的存储地址</strong></p>
<p> 散列函数：addr&#x3D;H(key)，建立了<strong>关键字到存储地址的映射关系</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610113134614.png" alt="image-20240610113134614"></p>
<p> 冲突：插入关键字，计算得到的addr处已经存储了其他元素，则产生了碰撞</p>
</li>
<li><p>散列函数的构造</p>
<ol>
<li><p>设计散列函数的目标：定义域涵盖所有关键字、值域不能超过散列表的地址范围、尽可能减少冲突，均匀分布在整个地址空间内、散列函数尽量简单，能够快速计算出散列地址</p>
</li>
<li><p>除留余数法（最常用）<br> $$<br> H(key)&#x3D;key%p<br> $$<br> 散列表长度为m，<strong>取一个不大于m但是接近或等于m的质数p</strong></p>
</li>
<li><p>直接定址法（关键字分布基本连续）<br> $$<br> H(key)&#x3D;key\<br> H(key)&#x3D;a*key+b<br> $$<br> 例如连续的学生学号，可以进行线性映射</p>
</li>
<li><p>数字分析法（关键字集合已知，且关键字某几个数码位分布均匀 ）</p>
<p> 选取数码分布较均匀的若干位作为散列地址，例如手机号的后四位</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114318528.png" alt="image-20240610114318528"></p>
</li>
<li><p>平方取中法（关键字的每位取值都不够均匀）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114422305.png" alt="image-20240610114422305"></p>
<p> 对关键字求平方，然后取中间两个数值位作为散列地址</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114509400.png" alt="image-20240610114509400"></p>
</li>
</ol>
</li>
<li><p>处理冲突的方法</p>
<ol>
<li><p>拉链法</p>
<ol>
<li><p>如何插入：把所有冲突的存储在一个链表中，默认头插法</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114742290.png" alt="image-20240610114742290"></p>
</li>
<li><p>如何查找（分析查找长度）</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114830228.png" alt="image-20240610114830228"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114855715.png" alt="image-20240610114855715"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610114914823.png" alt="image-20240610114914823"></p>
</li>
<li><p>如何删除</p>
<p> 先查找后删除</p>
</li>
</ol>
</li>
<li><p>开放寻址法</p>
<p> &#x3D;&#x3D;第一次冲突$d_i&#x3D;0$&#x3D;&#x3D;</p>
<ol>
<li><p>原理：如果插入元素时，发生冲突，<strong>就另外找一个空闲的位置</strong>，加上一个偏移序列<br> $$<br> H_i&#x3D;(H(key)+d_i)%m<br> $$</p>
</li>
<li><p>线性探测法</p>
<p> 对应第$i$次冲突<br> $$<br> d_i&#x3D;0,1,2,3,..,m-1<br> $$<br> 其实就是一个个往后找，直到找到为空的地方，将元素放进去</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610121414419.png" alt="image-20240610121414419"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610121127714.png" alt="image-20240610121127714"></p>
</li>
<li><p>平方探测法<br> $$<br> d_i&#x3D;0^2,1^2,-1^2,2^2,-2^2,…,k^2,-k^2,\ \ k&lt;&#x3D;m&#x2F;2<br> $$<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610121230578.png" alt="image-20240610121230578"></p>
</li>
<li><p>双散列法</p>
<p> $hash_2(key)&#x3D;13-(key%13)$<br> $$<br> d_i&#x3D;i*hash_2(key)<br> $$<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610121007013.png" alt="image-20240610121007013"></p>
</li>
<li><p>伪随机序列法</p>
<p> 让$d_i$是一个伪随机序列，然后根据这个$d_i$处理冲突<br> $$<br> d_i&#x3D;0,5,3,11<br> $$<br> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610121308805.png" alt="image-20240610121308805"></p>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">graph LR</span><br><span class="line">	排序--&gt;基本概念</span><br><span class="line">	基本概念--&gt;稳定性</span><br><span class="line">	基本概念--&gt;a1[&quot;衡量标准：时空复杂度&quot;]</span><br><span class="line">	排序--&gt;内部排序</span><br><span class="line">	内部排序--&gt;插入排序</span><br><span class="line">	插入排序--&gt;直接插入排序</span><br><span class="line">	插入排序--&gt;折半插入排序</span><br><span class="line">	插入排序--&gt;希尔排序</span><br><span class="line">	交换排序--&gt;冒泡排序</span><br><span class="line">	交换排序--&gt;快速排序</span><br><span class="line">	内部排序--&gt;交换排序</span><br><span class="line">	内部排序--&gt;选择排序</span><br><span class="line">	选择排序--&gt;简单选择排序</span><br><span class="line">	选择排序--&gt;堆排序</span><br><span class="line">	内部排序--&gt;归并排序</span><br><span class="line">	内部排序--&gt;基数排序</span><br><span class="line">	排序--&gt;外部排序</span><br><span class="line">	外部排序--&gt;多路归并排序</span><br></pre></td></tr></table></figure>

<h4 id="排序的基本概念"><a href="#排序的基本概念" class="headerlink" title="排序的基本概念"></a>排序的基本概念</h4><p>sort关键字有序，<strong>关键字可能重复，和前面不一样</strong></p>
<ol>
<li>排序算法的稳定性：经过排序算法处理后，相同的关键字，原本的相对位置没有改变</li>
<li>内部排序和外部排序：<strong>内部排序</strong>全在内存中，<strong>外部排序</strong>因为数据太多无法放入内存，也要关注磁盘的读写次数</li>
</ol>
<p><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610131509025.png" alt="image-20240610131509025"> </p>
<h4 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h4><h5 id="插入排序-1"><a href="#插入排序-1" class="headerlink" title="插入排序"></a>插入排序</h5><ol>
<li><p>算法思想：每次将一个待排序的记录，按其关键字大小<strong>插入到前面已经排序好的子序列中</strong>，直到全部插入</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610123132152.png" alt="image-20240610123132152"></p>
</li>
<li><p>时间复杂度$O(n^2)$、稳定的</p>
</li>
<li><p>优化：折半插入排序，因为前面已经有序了，因此可以用二分找到应该插入的位置 $O(nlogn)$</p>
</li>
</ol>
<h5 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h5><ol>
<li><p>算法思想：使得原本的序列保持基本上有序，这样插入排序的效率可以提高一点，然后逐步逼近全局有序</p>
<p> 将排序表分割成若干子表， $L[i,i+d,i+2d,..,i+kd]$，对各个子表进行直接插入排序，<strong>缩小增量d</strong>重复上述过程，直到$d&#x3D;1$为止</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610124756195.png" alt="image-20240610124756195"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610124930553.png" alt="image-20240610124930553"></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610124948493.png" alt="image-20240610124948493"></p>
<p> 总体基本有序了，然后再进行一次直接插入排序</p>
</li>
<li><p>时间复杂度$O(n^2)$、不稳定的</p>
</li>
</ol>
<h4 id="交换排序"><a href="#交换排序" class="headerlink" title="交换排序"></a>交换排序</h4><h5 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h5><ol>
<li><p>算法思想：从后往前，两两比较，大的元素下沉，小的元素上浮，<strong>每趟排序都会使得最小的元素浮到最上方</strong>，第$i$趟排序交换到第$i$个位置停下来就可以了，i从1开始，两个元素相同不必交换位置，可以保证稳定性，n-1趟即可</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610125618621.png" alt="image-20240610125618621"></p>
</li>
<li><p>时间复杂度$O(n^2)$、稳定的</p>
</li>
</ol>
<h5 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h5><ol>
<li><p>算法思想</p>
<p> 主要利用<strong>分治思想</strong>，详见算法</p>
<ol>
<li>令指针<code>i,j</code>指向数列的区间<strong>外侧</strong>，数列的中值记为<code>x</code></li>
<li>将数列中<code>≤x</code>的数放左段，<code>≥x</code>的数放右段</li>
<li>对于左右两段，再递归以上两个过程，直到每段只有一个数，即全部有序</li>
</ol>
</li>
<li><p>时间复杂度<code>O(nlogn)</code>、不稳定的</p>
</li>
</ol>
<h4 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h4><h5 id="选择排序-1"><a href="#选择排序-1" class="headerlink" title="选择排序"></a>选择排序</h5><ol>
<li><p>算法思想：每一趟在待排序元素中选取<strong>关键字最小或最大的元素</strong>加入到有序子序列（实现方式是和待排序元素的头部节点交换（图中蓝色）），n-1趟即可完成</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610130812140.png" alt="image-20240610130812140"></p>
</li>
<li><p>时间复杂度$O(n^2)$、不稳定的</p>
</li>
</ol>
<h5 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h5><ol>
<li><p>算法思想</p>
<ol>
<li><p><strong>堆的插入：</strong>先将元素从<strong>堆尾插入</strong>，然后<strong>上浮</strong>到合适的位置   <code>O(logn)</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000005</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span>&#123; <span class="comment">//上浮</span></span><br><span class="line">    <span class="keyword">if</span>(u / <span class="number">2</span> &amp;&amp; a[u] &lt; a[u / <span class="number">2</span>])</span><br><span class="line">        <span class="built_in">swap</span>(a[u], a[u / <span class="number">2</span>]), <span class="built_in">up</span>(u / <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span></span>&#123; <span class="comment">//压入</span></span><br><span class="line">    a[++ cnt] = x;</span><br><span class="line">    <span class="built_in">up</span>(cnt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
<li><p><strong>堆的删除：</strong>（删除最小的元素）先将<strong>堆顶</strong>的数和<strong>堆尾</strong>的数<strong>交换</strong>，<strong>删除堆尾</strong>，然后<strong>下沉</strong>操作 <code>O(logn)</code></p>
 <figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> a[<span class="number">1000005</span>], cnt;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span>&#123; <span class="comment">//下沉</span></span><br><span class="line">    <span class="type">int</span> v = u;</span><br><span class="line">    <span class="comment">// 找出子节点中较小的那个数</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u &lt;= cnt &amp;&amp; a[<span class="number">2</span> * u] &lt; a[v]) v = <span class="number">2</span> * u;</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">2</span> * u + <span class="number">1</span> &lt;= cnt &amp;&amp; a[<span class="number">2</span> * u + <span class="number">1</span>] &lt; a[v]) v = <span class="number">2</span> * u + <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//存在父节点比子节点大</span></span><br><span class="line">    <span class="keyword">if</span> (v != u) <span class="built_in">swap</span>(a[v], a[u]),<span class="built_in">down</span>(v);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pop</span><span class="params">()</span></span>&#123; <span class="comment">//删除</span></span><br><span class="line">    a[<span class="number">1</span>] = a[cnt --];</span><br><span class="line">    <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
<li><p>时间复杂度<code>O(nlogn)</code>、不稳定的</p>
</li>
</ol>
<h4 id="归并排序和基数排序"><a href="#归并排序和基数排序" class="headerlink" title="归并排序和基数排序"></a>归并排序和基数排序</h4><h5 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h5><ol>
<li><p>算法思想</p>
<p> 主要利用<strong>分治思想</strong>，时间复杂度<code>O(nlogn)</code></p>
<ol>
<li>对数组不断的等长<strong>拆分</strong>，直到一个数的长度</li>
<li>回溯时，按升序<strong>合并</strong>左右两段</li>
<li>重复以上两个过程，直至递归结束</li>
</ol>
<p> <strong>回溯合并</strong></p>
<ol>
<li><code>i,j</code>指针分别指向<code>a</code>的左右段起点，<code>k</code>指向<code>b</code>的起点</li>
<li>枚举<code>a</code>数组，如果左数 <strong>≤</strong> 右数，把左数放入<code>b</code>数组，否则，把右数放入<code>b</code>数组</li>
<li>把左段或右段剩余的数放入<code>b</code>数组</li>
<li>把<code>b</code>数组当前段复制回<code>a</code>数组，用于<code>a</code>数组的上一层回溯</li>
</ol>
</li>
<li><p>时间复杂度<code>O(nlogn)</code>、稳定的</p>
</li>
</ol>
<h5 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h5><ol>
<li><p>算法思想：建立r个队列</p>
<p> 以关键字的个位数排队，放入队列中</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610131613617.png" alt="image-20240610131613617"></p>
<p> 按顺序收集队列中的元素，组成链表 ，<strong>得到按照个位递减的排序序列</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610131848578.png" alt="image-20240610131848578"></p>
<p> 以关键字的十位数排队，放入队列中，<strong>个位越大的越先入队，使得大数在前，小数在后</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610132017492.png" alt="image-20240610132017492"></p>
<p> 收集，得到<strong>按十位递减的排序序列，十位相同的按照个位递减排序</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610132104732.png" alt="image-20240610132104732"></p>
<p> 以关键字的百位数排队，放入队列中，<strong>十位越大的越先入队，使得大数在前，小数在后</strong></p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610132203118.png" alt="image-20240610132203118"></p>
<p> 收集，得到<strong>按百位递减的排序序列，百位相同按照十位递减排序，十位相同的按照个位递减排序</strong>，最终有序</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/./.assets/image-20240610132242702.png" alt="image-20240610132242702"></p>
</li>
<li><p>时间复杂度$O(d(n+r))$，稳定的</p>
</li>
</ol>
<h4 id="外部排序"><a href="#外部排序" class="headerlink" title="外部排序"></a>外部排序</h4></article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">11andyy</div><div class="post-copyright__author_desc">生活明朗，万物可爱</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/')">数据结构</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="/img/wechatpay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/wechatpay.jpg" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/img/alipay.jpg" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/alipay.jpg" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=数据结构&amp;url=https://11andyy.github.io/2024/03/17/408/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/&amp;pic=https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729161024495.png" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://11andyy.github.io" target="_blank">11的Blog</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/408/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>408<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>数据结构<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/TZd_M78N.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/01/17/Tools/Latex/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/P04yDxna.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Latex</div></div></a></div><div class="next-post pull-right"><a href="/2024/03/27/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729160644203.png" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">计算机网络</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2024/05/27/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729160517509.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-05-27</div><div class="title">操作系统</div></div></a></div><div><a href="/2024/04/27/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" title="计算机组成原理"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729160854326.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-27</div><div class="title">计算机组成原理</div></div></a></div><div><a href="/2024/03/27/408/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" title="计算机网络"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729160644203.png" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-03-27</div><div class="title">计算机网络</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/avatar.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/><div class="author-status"><img class="g-status" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/24/64e6ce9c507bb.png" alt="status"/></div></div><div class="author-info__description"><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">本博客建立的初衷是为了记录一路走来学习的计算机专业知识,方便之后复习与查看,<b style="color:#fff">起于此，但不止于此</b>,勤能补拙，相信一点点的积累最后汇聚成海!</div><div style="line-height:1.38;margin:0.6rem 0;text-align:justify;color:rgba(255, 255, 255, 0.8);">希望我的这个小小的计划,可以真正地帮助到实力强大的你!</div></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">11andyy</h1><div class="author-info__desc">生活明朗，万物可爱</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/11andyy" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/372204786" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bullhorn anzhiyu-shake"></i><span>公告</span></div><div class="announcement_content">欢迎来看我的博客鸭~</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%AA%E8%AE%BA"><span class="toc-number">1.1.</span> <span class="toc-text">绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.1.1.</span> <span class="toc-text">数据结构的基本概念</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%9A%84%E4%B8%89%E8%A6%81%E7%B4%A0"><span class="toc-number">1.1.1.1.</span> <span class="toc-text">数据结构的三要素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%92%8C%E7%AE%97%E6%B3%95%E8%AF%84%E4%BB%B7"><span class="toc-number">1.1.2.</span> <span class="toc-text">算法和算法评价</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E6%95%88%E7%8E%87%E7%9A%84%E5%BA%A6%E9%87%8F"><span class="toc-number">1.1.2.1.</span> <span class="toc-text">算法效率的度量</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.2.1.1.</span> <span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%A9%BA%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-number">1.1.2.1.2.</span> <span class="toc-text">空间复杂度</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-A"><span class="toc-number">1.1.3.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-number">1.2.</span> <span class="toc-text">线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%AE%9A%E4%B9%89%E5%92%8C%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.</span> <span class="toc-text">线性表的基本定义和基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-number">1.2.1.1.</span> <span class="toc-text">线性表的定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C"><span class="toc-number">1.2.1.2.</span> <span class="toc-text">线性表的基本操作</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%92%8C%E9%93%BE%E8%A1%A8%E7%9A%84%E6%AF%94%E8%BE%83"><span class="toc-number">1.2.2.</span> <span class="toc-text">顺序表和链表的比较</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-A-1"><span class="toc-number">1.2.3.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88%E3%80%81%E9%98%9F%E5%88%97%E3%80%81%E6%95%B0%E7%BB%84"><span class="toc-number">1.3.</span> <span class="toc-text">栈、队列、数组</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88"><span class="toc-number">1.3.1.</span> <span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.1.1.</span> <span class="toc-text">栈的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E3%80%81%E9%93%BE%E6%A0%88%E3%80%81%E5%85%B1%E4%BA%AB%E6%A0%88"><span class="toc-number">1.3.1.2.</span> <span class="toc-text">顺序栈、链栈、共享栈</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.</span> <span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.3.2.1.</span> <span class="toc-text">队列的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E5%BC%8F%E5%AF%B9%E8%81%94%E3%80%81%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97%E3%80%81%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-number">1.3.2.2.</span> <span class="toc-text">顺序队列、链式对联、双端队列、循环队列</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.</span> <span class="toc-text">栈和队列的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.3.1.</span> <span class="toc-text">栈在括号匹配中的算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B1%82%E5%80%BC%E4%B8%AD%E7%9A%84%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3"><span class="toc-number">1.3.3.2.</span> <span class="toc-text">栈在后缀表达式求值中的算法思想</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%88%E5%9C%A8%E9%80%92%E5%BD%92%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.3.</span> <span class="toc-text">栈在递归中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.4.</span> <span class="toc-text">队列在层次遍历中的应用</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%98%9F%E5%88%97%E5%9C%A8%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.3.3.5.</span> <span class="toc-text">队列在计算机系统中的应用</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E5%92%8C%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.4.</span> <span class="toc-text">数组和特殊矩阵</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E7%BB%84%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F"><span class="toc-number">1.3.4.1.</span> <span class="toc-text">数组的存储方式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9F%A9%E9%98%B5"><span class="toc-number">1.3.4.2.</span> <span class="toc-text">特殊矩阵</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Q-A-2"><span class="toc-number">1.3.5.</span> <span class="toc-text">Q&amp;A</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%B2"><span class="toc-number">1.4.</span> <span class="toc-text">串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%B2%E7%9A%84%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="toc-number">1.4.1.</span> <span class="toc-text">串的模式匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-number">1.5.</span> <span class="toc-text">树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.5.1.</span> <span class="toc-text">树和二叉树的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-number">1.5.2.</span> <span class="toc-text">树和二叉树的性质</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.3.</span> <span class="toc-text">树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-number">1.5.4.</span> <span class="toc-text">二叉树的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.5.</span> <span class="toc-text">二叉树的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.5.6.</span> <span class="toc-text">树和森林的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88%E6%B2%A1%E5%AD%A6%EF%BC%89"><span class="toc-number">1.5.7.</span> <span class="toc-text">线索二叉树（没学）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E4%BA%8C%E5%8F%89%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E7%9A%84%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.5.8.</span> <span class="toc-text">树、二叉树、森林的转换</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BA%94%E7%94%A8"><span class="toc-number">1.5.9.</span> <span class="toc-text">树和二叉树的应用</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91%E5%92%8C%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81"><span class="toc-number">1.5.9.1.</span> <span class="toc-text">哈夫曼树和哈夫曼编码</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.5.9.2.</span> <span class="toc-text">并查集</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE"><span class="toc-number">1.6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.6.1.</span> <span class="toc-text">图的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-number">1.6.2.</span> <span class="toc-text">图的存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-number">1.6.3.</span> <span class="toc-text">图的遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.6.4.</span> <span class="toc-text">最小生成树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Kruskal%EF%BC%88%E7%A8%80%E7%96%8F%E5%9B%BE%EF%BC%89"><span class="toc-number">1.6.4.1.</span> <span class="toc-text">Kruskal（稀疏图）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Prim%EF%BC%88%E7%A8%A0%E5%AF%86%E5%9B%BE%EF%BC%89"><span class="toc-number">1.6.4.2.</span> <span class="toc-text">Prim（稠密图）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84"><span class="toc-number">1.6.5.</span> <span class="toc-text">最短路径</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Dijkstra"><span class="toc-number">1.6.5.1.</span> <span class="toc-text">Dijkstra</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Bellman-Ford"><span class="toc-number">1.6.5.2.</span> <span class="toc-text">Bellman-Ford</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Spfa"><span class="toc-number">1.6.5.3.</span> <span class="toc-text">Spfa</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#Floyd"><span class="toc-number">1.6.5.4.</span> <span class="toc-text">Floyd</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.7.1.</span> <span class="toc-text">查找的基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">查找类型</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BA%BF%E5%BD%A2%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">线形查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.1.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8A%98%E5%8D%8A%E6%9F%A5%E6%89%BE%EF%BC%88%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%EF%BC%89"><span class="toc-number">1.7.2.1.2.</span> <span class="toc-text">折半查找（二分查找）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%88%86%E5%9D%97%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.1.3.</span> <span class="toc-text">分块查找</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%91%E5%BD%A2%E6%9F%A5%E6%89%BE"><span class="toc-number">1.7.2.2.</span> <span class="toc-text">树形查找</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89"><span class="toc-number">1.7.2.2.1.</span> <span class="toc-text">二叉排序树（BST）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%88AVL%EF%BC%89"><span class="toc-number">1.7.2.2.2.</span> <span class="toc-text">平衡二叉树（AVL）</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E7%BA%A2%E9%BB%91%E6%A0%91%EF%BC%88RBT%EF%BC%89"><span class="toc-number">1.7.2.2.3.</span> <span class="toc-text">红黑树（RBT）</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#B%E6%A0%91%E5%92%8CB-%E6%A0%91"><span class="toc-number">1.7.2.3.</span> <span class="toc-text">B树和B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#B%E6%A0%91"><span class="toc-number">1.7.2.3.1.</span> <span class="toc-text">B树</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#B-%E6%A0%91"><span class="toc-number">1.7.2.3.2.</span> <span class="toc-text">B+树</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-number">1.7.2.4.</span> <span class="toc-text">散列表</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-number">1.8.0.1.</span> <span class="toc-text">排序的基本概念</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.2.</span> <span class="toc-text">插入排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.8.0.2.1.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.2.2.</span> <span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.3.</span> <span class="toc-text">交换排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.3.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.3.2.</span> <span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.4.</span> <span class="toc-text">选择排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F-1"><span class="toc-number">1.8.0.4.1.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.4.2.</span> <span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F%E5%92%8C%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.5.</span> <span class="toc-text">归并排序和基数排序</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.5.1.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.5.2.</span> <span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%96%E9%83%A8%E6%8E%92%E5%BA%8F"><span class="toc-number">1.8.0.6.</span> <span class="toc-text">外部排序</span></a></li></ol></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2024/07/30/AutonomousDriving/carla/" title="Carla"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/TZd_M78N.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Carla"/></a><div class="content"><a class="title" href="/2024/07/30/AutonomousDriving/carla/" title="Carla">Carla</a><time datetime="2024-07-30T09:52:03.000Z" title="发表于 2024-07-30 17:52:03">2024-07-30</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/29/AutonomousDriving/ros/" title="Ros"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729163319802.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Ros"/></a><div class="content"><a class="title" href="/2024/07/29/AutonomousDriving/ros/" title="Ros">Ros</a><time datetime="2024-07-29T10:02:03.000Z" title="发表于 2024-07-29 18:02:03">2024-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/29/Tutorial/Github%E5%9B%BE%E5%BA%8A/" title="Github搭建免费图床"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729153157616.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Github搭建免费图床"/></a><div class="content"><a class="title" href="/2024/07/29/Tutorial/Github%E5%9B%BE%E5%BA%8A/" title="Github搭建免费图床">Github搭建免费图床</a><time datetime="2024-07-29T07:58:03.000Z" title="发表于 2024-07-29 15:58:03">2024-07-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/07/27/Language/Python/" title="Python"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/GdLgIkCU.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Python"/></a><div class="content"><a class="title" href="/2024/07/27/Language/Python/" title="Python">Python</a><time datetime="2024-07-27T10:02:03.000Z" title="发表于 2024-07-27 18:02:03">2024-07-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2024/05/27/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://cdn.jsdelivr.net/gh/11andyy/Pic0@master/img/image-20240729160517509.png" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="操作系统"/></a><div class="content"><a class="title" href="/2024/05/27/408/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" title="操作系统">操作系统</a><time datetime="2024-05-27T10:02:03.000Z" title="发表于 2024-05-27 18:02:03">2024-05-27</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><p id="ghbdages"><a class="github-badge" target="_blank" href="https://hexo.io/" style="margin-inline:5px" data-title="博客框架为Hexo_v7.3.0" title="博客框架为Hexo_v7.3.0"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Frame-Hexo.svg" alt="博客框架为Hexo_v7.3.0"/></a><a class="github-badge" target="_blank" href="https://blog.anheyu.com/" style="margin-inline:5px" data-title="本站使用AnZhiYu主题" title="本站使用AnZhiYu主题"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.9/img/Theme-AnZhiYu-2E67D3.svg" alt="本站使用AnZhiYu主题"/></a><a class="github-badge" target="_blank" href="https://github.com/" style="margin-inline:5px" data-title="本站项目由Github托管" title="本站项目由Github托管"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.1.5/img/badge/Source-Github.svg" alt="本站项目由Github托管"/></a><a class="github-badge" target="_blank" href="http://creativecommons.org/licenses/by-nc-sa/4.0/" style="margin-inline:5px" data-title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@2.2.0/img/badge/Copyright-BY-NC-SA.svg" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可"/></a></p></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2021 - 2024 By <a class="footer-bar-link" href="/" title="11andyy" target="_blank">11andyy</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">19</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">29</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">5</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://index.anheyu.com/" title="个人主页"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2748ef34.jpg" alt="个人主页"/><span class="back-menu-item-text">个人主页</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/07/23/64bc72c75319d.png" alt="博客"/><span class="back-menu-item-text">博客</span></a><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/08/13/64d8c2653332e.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/408/" style="font-size: 0.88rem;">408<sup>4</sup></a><a href="/tags/Anaconda/" style="font-size: 0.88rem;">Anaconda<sup>1</sup></a><a href="/tags/Carla/" style="font-size: 0.88rem;">Carla<sup>1</sup></a><a href="/tags/Docker/" style="font-size: 0.88rem;">Docker<sup>1</sup></a><a href="/tags/Git/" style="font-size: 0.88rem;">Git<sup>1</sup></a><a href="/tags/Latex/" style="font-size: 0.88rem;">Latex<sup>1</sup></a><a href="/tags/Linux/" style="font-size: 0.88rem;">Linux<sup>1</sup></a><a href="/tags/Pipe/" style="font-size: 0.88rem;">Pipe<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>1</sup></a><a href="/tags/Ros/" style="font-size: 0.88rem;">Ros<sup>1</sup></a><a href="/tags/SCP/" style="font-size: 0.88rem;">SCP<sup>1</sup></a><a href="/tags/SSH/" style="font-size: 0.88rem;">SSH<sup>1</sup></a><a href="/tags/Tmux/" style="font-size: 0.88rem;">Tmux<sup>2</sup></a><a href="/tags/Vim/" style="font-size: 0.88rem;">Vim<sup>2</sup></a><a href="/tags/easyRL%E7%A3%A8%E8%8F%87%E4%B9%A6/" style="font-size: 0.88rem;">easyRL磨菇书<sup>1</sup></a><a href="/tags/%E5%9B%BE%E5%BA%8A/" style="font-size: 0.88rem;">图床<sup>1</sup></a><a href="/tags/%E5%AE%9E%E7%94%A8%E6%95%99%E7%A8%8B/" style="font-size: 0.88rem;">实用教程<sup>1</sup></a><a href="/tags/%E5%B7%A5%E5%85%B7%E9%85%8D%E7%BD%AE/" style="font-size: 0.88rem;">工具配置<sup>1</sup></a><a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">强化学习<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>2</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%96%87%E6%9C%AC%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">文本编辑工具<sup>2</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">机器人操作系统<sup>1</sup></a><a href="/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0%E5%B7%A5%E5%85%B7/" style="font-size: 0.88rem;">深度学习工具<sup>5</sup></a><a href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/" style="font-size: 0.88rem;">编程语言<sup>1</sup></a><a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6/" style="font-size: 0.88rem;">自动驾驶<sup>2</sup></a><a href="/tags/%E8%87%AA%E5%8A%A8%E9%A9%BE%E9%A9%B6%E4%BB%BF%E7%9C%9F/" style="font-size: 0.88rem;">自动驾驶仿真<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/" style="font-size: 0.88rem;">计算机组成原理<sup>1</sup></a><a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">计算机网络<sup>1</sup></a></div></div><hr/></div></div><div id="keyboard-tips"><div class="keyboardTitle">博客快捷键</div><div class="keybordList"><div class="keybordItem"><div class="keyGroup"><div class="key">shift K</div></div><div class="keyContent"><div class="content">关闭快捷键功能</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift A</div></div><div class="keyContent"><div class="content">打开/关闭中控台</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift M</div></div><div class="keyContent"><div class="content">播放/暂停音乐</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift D</div></div><div class="keyContent"><div class="content">深色/浅色显示模式</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift S</div></div><div class="keyContent"><div class="content">站内搜索</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift R</div></div><div class="keyContent"><div class="content">随机访问</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift H</div></div><div class="keyContent"><div class="content">返回首页</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift F</div></div><div class="keyContent"><div class="content">友链鱼塘</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift L</div></div><div class="keyContent"><div class="content">友链页面</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift P</div></div><div class="keyContent"><div class="content">关于本站</div></div></div><div class="keybordItem"><div class="keyGroup"><div class="key">shift I</div></div><div class="keyContent"><div class="content">原版/本站右键菜单</div></div></div></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="chat-btn" type="button" title="聊天"><i class="anzhiyufont anzhiyu-icon-comment-sms"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2021 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 11andyy 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><script src="/js/anzhiyu/right_click_menu.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><script>(() => {
  const isChatBtn = true
  const isChatHideShow = false

  if (isChatBtn) {
    const close = () => {
      Chatra('minimizeWidget')
      Chatra('hide')
    }

    const open = () => {
      Chatra('openChat', true)
      Chatra('show')
    }

    window.ChatraSetup = {
      startHidden: true
    }
  
    window.chatBtnFn = () => {
      const isShow = document.getElementById('chatra').classList.contains('chatra--expanded')
      isShow ? close() : open()
    }
  } else if (isChatHideShow) {
    window.chatBtn = {
      hide: () => {
        Chatra('hide')
      },
      show: () => {
        Chatra('show')
      }
    }
  }

  (function(d, w, c) {
    w.ChatraID = 'XuXAxHxmtsvpjunNh'
    var s = d.createElement('script')
    w[c] = w[c] || function() {
        (w[c].q = w[c].q || []).push(arguments)
    }
    s.async = true
    s.src = 'https://call.chatra.io/chatra.js'
    if (d.head) d.head.appendChild(s)
  })(document, window, 'Chatra')

})()</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>